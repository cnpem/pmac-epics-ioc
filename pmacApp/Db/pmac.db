##############################################################
#
# Records to read asynPortDriver parameters from the param 
# library for the class pmacController.
#
# The Asyn address is set as zero because that's what we use 
# for controller parameters.
# 
##############################################################

# % macro, PORT, The asyn port for the pmac controller
# % macro, P, PV Prefix
# % macro, NAXES, Number of axes
# % macro, TIMEOUT, Timeout for controller communication
# % macro, FEEDRATE, feedrate below which we go into error
# % macro, CSG0, Name for Coordinate System Group 0
# % macro, CSG1, Name for Coordinate System Group 1
# % macro, CSG2, Name for Coordinate System Group 2
# % macro, CSG3, Name for Coordinate System Group 3
# % macro, CSG4, Name for Coordinate System Group 4
# % macro, CSG5, Name for Coordinate System Group 5
# % macro, CSG6, Name for Coordinate System Group 6
# % macro, CSG7, Name for Coordinate System Group 7

#
# This associates an edm screen with the template
# % gui, Brick, edm, pmacController.edl, pmac=BRICK1
#

#
# allow query of this controller's Port Name
#
record(stringout, "BRICK1:Port")
{
    field(VAL, "Brick")
    field(PINI, "YES")
}

##############################################################
# Ensure all PVs are up to date with the current brick state
##############################################################
record(busy,"BRICK1:PollAllNow") {
    field(DESC,"Poll brick status")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,0)PMAC_C_POLLALLNOW")
    field(ZNAM, "Done")
    field(ONAM, "Polling")
}

##############################################################
# Control deferred mode for all real 1axes in this brick
##############################################################
record(bo, "BRICK1:DeferMoves")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,0,4)MOTOR_DEFER_MOVES")
    field(VAL, "0")
    field(ZNAM, "Defer Off")
    field(ONAM, "Defer On")
}

##############################################################
# Send stop all command
##############################################################
record(bo, "BRICK1:StopAll")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,0,4)PMAC_C_STOPALL")
}

##############################################################
# Control deferred mode for all real 1axes in this brick
##############################################################
record(bo, "BRICK1:KillAll")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,0,4)PMAC_C_KILLALL")
}

##############################################################
# Send arbitrary command to the geobrick controller
##############################################################
record(waveform, "BRICK1:SendCmd")
{
    field(DTYP, "asynOctetWrite")
    field(FTVL, "CHAR")
    field(INP,  "@asyn(Brick,0,4)PMAC_C_WRITE_CMD")
    field(NELM, "100")
    field(SCAN, "Passive")
}


# a dummy real motor 0 with mres of 1, used by the CS axis mres DB logic in pmacDirectMotor.template
record(motor,"BRICK1M0")
{
	field(DTYP,"Soft Channel")
	field(MRES,"1")
}

# ///
# /// Select a group of coordinate systems into the controller.
# ///
# % autosave 2
record(mbbo, "BRICK1:COORDINATE_SYS_GROUP")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(Brick,0,4)PMAC_C_COORDINATE_SYS_GROUP")
   field(VAL, "0")
   field(ZRST, "")
   field(ZRVL, "0")
   field(ONST, "")
   field(ONVL, "1")
   field(TWST, "")
   field(TWVL, "2")
   field(THST, "")
   field(THVL, "3")
   field(FRST, "")
   field(FRVL, "4")
   field(FVST, "")
   field(FVVL, "5")
   field(SXST, "")
   field(SXVL, "6")
   field(SVST, "")
   field(SVVL, "7")
}

# ///
# /// Read back the current group of coordinate systems into the controller.
# ///
record(mbbi, "BRICK1:COORDINATE_SYS_GROUP_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(Brick,0,4)PMAC_C_COORDINATE_SYS_GROUP")
   field(SCAN, "I/O Intr")
   field(ZRST, "")
   field(ZRVL, "0")
   field(ONST, "")
   field(ONVL, "1")
   field(TWST, "")
   field(TWVL, "2")
   field(THST, "")
   field(THVL, "3")
   field(FRST, "")
   field(FRVL, "4")
   field(FVST, "")
   field(FVVL, "5")
   field(SXST, "")
   field(SXVL, "6")
   field(SVST, "")
   field(SVVL, "7")
}

#
# Control read only mode for axes
#
record(bo, "BRICK1:AxesReadonly")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,0,4)PMAC_C_AXIS_READONLY")
    field(VAL, "0")
    field(ZNAM, "Read/Write")
    field(ONAM, "Readonly")
}

#
# Read back the readonly mode for axes
# 
record(bi, "BRICK1:AxesReadonly_RBV")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn(Brick,0,4)PMAC_C_AXIS_READONLY")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Read/Write")
    field(ONAM, "Readonly")
}

##############################################################
# Record of the Kinematics on the PMAC
##############################################################
record(waveform, "BRICK1:FWD_KINEMATIC_1_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_1")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_2_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_2")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_3_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_3")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_4_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_4")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_5_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_5")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_6_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_6")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_7_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_7")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_8_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_8")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_9_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_9")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_10_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_10")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_11_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_11")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_12_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_12")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_13_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_13")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_14_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_14")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_15_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_15")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:FWD_KINEMATIC_16_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_FWD_KIN_16")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_1_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_1")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_2_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_2")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_3_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_3")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_4_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_4")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_5_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_5")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_6_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_6")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_7_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_7")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_8_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_8")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_9_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_9")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_10_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_10")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_11_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_11")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_12_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_12")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_13_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_13")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_14_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_14")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_15_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_15")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}

record(waveform, "BRICK1:INV_KINEMATIC_16_RBV")
{
  field(DTYP, "asynOctetRead")
  field(INP,  "@asyn(Brick,0)PMAC_C_INV_KIN_16")
  field(FTVL, "CHAR")
  field(NELM, "20000")
  field(SCAN, "I/O Intr")
}


#####################################################
# Below are the records originally from
#    pmacStatus.template
#####################################################

# pmac type record
record(mbbi, "BRICK1:PMACTYPE") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(ZRVL, "604020")
  field(ONVL, "602413")
  field(TWVL, "603382")
  field(THVL, "602404")
  field(ZRST, "Power PMAC")
  field(ONST, "Turbo PMAC2")
  field(TWST, "Geobrick LV")
  field(THST, "PMAC Clipper")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VIM_cid")
}

# % archiver 10 Monitor
# This makes the component icon reflect the severity
# % gui, Brick, sevr
record(ai, "BRICK1:CPULOAD") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_CPU_USAGE")
  field(PREC, "2")
  field(EGU, "%")
  field(HIGH, "60")
  field(HSV, "MINOR")
  field(HIHI, "80")
  field(HHSV, "MAJOR")
}

record(ai, "BRICK1:SERVO_FREQ") {
  field(EGU, "Hz")
  field(PREC, "1")
}

record(longin, "BRICK1:READ_CTRLSTAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_STATUS_BITS01")
  field(FLNK, "BRICK1:CTRLSTAT:status1")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:CTRLSTAT:status1") {
  field(INP, "BRICK1:READ_CTRLSTAT1")
}

record(longin, "BRICK1:READ_CTRLSTAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_STATUS_BITS02")
  field(FLNK, "BRICK1:CTRLSTAT:status2")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:CTRLSTAT:status2") {
  field(INP, "BRICK1:READ_CTRLSTAT2")
}

record(longin, "BRICK1:READ_CTRLSTAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_STATUS_BITS03")
  field(FLNK, "BRICK1:CTRLSTAT:status3")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:CTRLSTAT:status3") {
  field(INP, "BRICK1:READ_CTRLSTAT3")
}


record(longin, "BRICK1:READ_PLCBITS00") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_PLC_BITS00")
  field(FLNK, "BRICK1:PLCDISBITS00")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:PLCDISBITS00") {
  field(INP, "BRICK1:READ_PLCBITS00")
}

record(longin, "BRICK1:READ_PLCBITS01") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_PLC_BITS01")
  field(FLNK, "BRICK1:PLCDISBITS01")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:PLCDISBITS01") {
  field(INP, "BRICK1:READ_PLCBITS01")
}

record(longin, "BRICK1:READ_GPIO_INP") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_GPIO_INPUTS")
  field(FLNK, "BRICK1:GPIO_INP_BITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:GPIO_INP_BITS") {
  field(INP, "BRICK1:READ_GPIO_INP")
}

record(longin, "BRICK1:READ_GPIO_OUT") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_GPIO_OUTPUTS")
  field(FLNK, "BRICK1:GPIO_OP_BITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:GPIO_OP_BITS") {
  field(INP, "BRICK1:READ_GPIO_OUT")
}

record(longin, "BRICK1:READ_PROGBITS") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_C_PROG_BITS")
  field(FLNK, "BRICK1:PROGBITS")
}

# % archiver 10 Monitor
record(mbbiDirect, "BRICK1:PROGBITS") {
  field(INP, "BRICK1:READ_PROGBITS")
}

record(ai, "BRICK1:MACROERRS") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDM_M5035")
}

record(seq, "BRICK1:AXIS1:ReadBack") {
}

record(seq, "BRICK1:AXIS2:ReadBack") {
}

record(seq, "BRICK1:AXIS3:ReadBack") {
}

record(seq, "BRICK1:AXIS4:ReadBack") {
}

record(seq, "BRICK1:AXIS5:ReadBack") {
}

record(seq, "BRICK1:AXIS6:ReadBack") {
}

record(seq, "BRICK1:AXIS7:ReadBack") {
}

record(seq, "BRICK1:AXIS8:ReadBack") {
}

record(seq, "BRICK1:AXIS9:ReadBack") {
}

record(seq, "BRICK1:AXIS10:ReadBack") {
}

record(seq, "BRICK1:AXIS11:ReadBack") {
}

record(seq, "BRICK1:AXIS12:ReadBack") {
}

record(seq, "BRICK1:AXIS13:ReadBack") {
}

record(seq, "BRICK1:AXIS14:ReadBack") {
}

record(seq, "BRICK1:AXIS15:ReadBack") {
}

record(seq, "BRICK1:AXIS16:ReadBack") {
}

record(seq, "BRICK1:AXIS17:ReadBack") {
}

record(seq, "BRICK1:AXIS18:ReadBack") {
}

record(seq, "BRICK1:AXIS19:ReadBack") {
}

record(seq, "BRICK1:AXIS20:ReadBack") {
}

record(seq, "BRICK1:AXIS21:ReadBack") {
}

record(seq, "BRICK1:AXIS22:ReadBack") {
}

record(seq, "BRICK1:AXIS23:ReadBack") {
}

record(seq, "BRICK1:AXIS24:ReadBack") {
}

record(seq, "BRICK1:AXIS25:ReadBack") {
}

record(seq, "BRICK1:AXIS26:ReadBack") {
}

record(seq, "BRICK1:AXIS27:ReadBack") {
}

record(seq, "BRICK1:AXIS28:ReadBack") {
}

record(seq, "BRICK1:AXIS29:ReadBack") {
}

record(seq, "BRICK1:AXIS30:ReadBack") {
}

record(seq, "BRICK1:AXIS31:ReadBack") {
}

record(seq, "BRICK1:AXIS32:ReadBack") {
}

record(seq, "BRICK1:AxisRB") {
  field(LNK1, "BRICK1:AXIS1:ReadBack.PROC PP")
  field(LNK2, "BRICK1:AXIS2:ReadBack.PROC PP")
  field(LNK3, "BRICK1:AXIS3:ReadBack.PROC PP")
  field(LNK4, "BRICK1:AXIS4:ReadBack.PROC PP")
  field(LNK5, "BRICK1:AXIS5:ReadBack.PROC PP")
  field(LNK6, "BRICK1:AXIS6:ReadBack.PROC PP")
  field(LNK7, "BRICK1:AXIS7:ReadBack.PROC PP")
  field(LNK8, "BRICK1:AXIS8:ReadBack.PROC PP")
  field(LNK9, "BRICK1:AxisRB2.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BRICK1:AxisRB2") {
  field(LNK1, "BRICK1:AXIS9:ReadBack.PROC PP")
  field(LNK2, "BRICK1:AXIS10:ReadBack.PROC PP")
  field(LNK3, "BRICK1:AXIS11:ReadBack.PROC PP")
  field(LNK4, "BRICK1:AXIS12:ReadBack.PROC PP")
  field(LNK5, "BRICK1:AXIS13:ReadBack.PROC PP")
  field(LNK6, "BRICK1:AXIS14:ReadBack.PROC PP")
  field(LNK7, "BRICK1:AXIS15:ReadBack.PROC PP")
  field(LNK8, "BRICK1:AXIS16:ReadBack.PROC PP")
  field(LNK9, "BRICK1:AxisRB3.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BRICK1:AxisRB3") {
  field(LNK1, "BRICK1:AXIS17:ReadBack.PROC PP")
  field(LNK2, "BRICK1:AXIS18:ReadBack.PROC PP")
  field(LNK3, "BRICK1:AXIS19:ReadBack.PROC PP")
  field(LNK4, "BRICK1:AXIS20:ReadBack.PROC PP")
  field(LNK5, "BRICK1:AXIS21:ReadBack.PROC PP")
  field(LNK6, "BRICK1:AXIS22:ReadBack.PROC PP")
  field(LNK7, "BRICK1:AXIS23:ReadBack.PROC PP")
  field(LNK8, "BRICK1:AXIS24:ReadBack.PROC PP")
  field(LNK9, "BRICK1:AxisRB4.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DLY9, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
  field(DOL9, "1")
}

record(seq, "BRICK1:AxisRB4") {
  field(LNK1, "BRICK1:AXIS25:ReadBack.PROC PP")
  field(LNK2, "BRICK1:AXIS26:ReadBack.PROC PP")
  field(LNK3, "BRICK1:AXIS27:ReadBack.PROC PP")
  field(LNK4, "BRICK1:AXIS28:ReadBack.PROC PP")
  field(LNK5, "BRICK1:AXIS29:ReadBack.PROC PP")
  field(LNK6, "BRICK1:AXIS30:ReadBack.PROC PP")
  field(LNK7, "BRICK1:AXIS31:ReadBack.PROC PP")
  field(LNK8, "BRICK1:AXIS32:ReadBack.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DLY5, "0.5")
  field(DLY6, "0.5")
  field(DLY7, "0.5")
  field(DLY8, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
  field(DOL5, "1")
  field(DOL6, "1")
  field(DOL7, "1")
  field(DOL8, "1")
}

record(longin, "BRICK1:NAXES") {
  field(PINI, "YES")
  field(VAL, "8")
}

##############################################################
# This record indicates if we have a controller problem
##############################################################

# ///
# /// Record used to indicate if the controller has a problem. This is set in the
# /// controller poll loop, and is used to set the motor record axis status.
# ///
record(bi, "BRICK1:GLOBAL_PROBLEM_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(Brick,0,4)PMAC_C_GLOBALSTATUS")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Status OK")
   field(ONAM, "Status Problem")
}

##############################################################
# Monitor and set the PMAC feedrate
##############################################################

# ///
# /// Get the PMAC feedrate. This is read in the controller poll loop.
# ///
record(ai, "BRICK1:FEEDRATE_RBV")
{
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(Brick,0,4)PMAC_C_FEEDRATE")
   field(SCAN, "I/O Intr")
   field(PREC, "2")
}

# ///
# /// Set the PMAC feedrate limit. This determins if the current feedrate
# /// read from the controller is out of range, and will be used to set axis alarms.
# ///
record(longout, "BRICK1:FEEDRATE_LIMIT")
{
   field(PINI, "YES")
   field(VAL, "100")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(Brick,0,4)PMAC_C_FEEDRATE_LIMIT")
   field(DRVH, "100")
   field(DRVL, "0")
}

# ///
# /// Set the PMAC feedrate limit. This writes a new feedrate to
# /// the controller.
# ///
record(longout, "BRICK1:FEEDRATE")
{
   field(PINI, "YES")
   field(VAL, "100")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn(Brick,0,4)PMAC_C_FEEDRATE")
   field(DRVH, "100")
   field(DRVL, "0")
}

# ///
# /// Record used to indicate if the feedrate is below the limit. This is set from the
# /// controller poll loop, and is used to set the motor record axis status.
# ///
record(bi, "BRICK1:FEEDRATE_PROBLEM_RBV")
{
   field(PINI, "YES")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn(Brick,0,4)PMAC_C_FEEDRATE_PROBLEM")
   field(SCAN, "I/O Intr")
   field(ZNAM, "Feedrate OK")
   field(ONAM, "Feedrate Problem")
}

###################################################################
#  These records report the current comms statistics              #
#                                                                 #
###################################################################

record(longin, "BRICK1:STAT_MSG_NO_RBV") {
  field(DESC, "Number of messages sent")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_NO_OF_MSGS")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_TOTAL_WRITE_RBV") {
  field(DESC, "Total bytes written")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_TBYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_TOTAL_READ_RBV") {
  field(DESC, "Total bytes read")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_TBYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MSG_WRITE_RBV") {
  field(DESC, "Last message bytes written")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MBYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MSG_READ_RBV") {
  field(DESC, "Last message bytes read")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MBYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MSG_TIME_RBV") {
  field(DESC, "Last message time (ms)")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MSG_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MAX_WRITE_RBV") {
  field(DESC, "Maximum written bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MAX_BYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MAX_READ_RBV") {
  field(DESC, "Maximum read bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MAX_BYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_MAX_TIME_RBV") {
  field(DESC, "Maximum time for message")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MAX_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_AVE_WRITE_RBV") {
  field(DESC, "Average written bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_AVE_BYTES_WRITE")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_AVE_READ_RBV") {
  field(DESC, "Average read bytes")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_AVE_BYTES_READ")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:STAT_AVE_TIME_RBV") {
  field(DESC, "Average time for message")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_AVE_TIME")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:FAST_SIZE_RBV") {
  field(DESC, "Size of fast PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_FAST_STORE")
  field(SCAN, "I/O Intr")
}

record(longout, "BRICK1:REPORT_FAST") {
  field(DESC, "Report the contents of fast store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_REPORT_FAST")
}

record(longin, "BRICK1:MEDIUM_SIZE_RBV") {
  field(DESC, "Size of medium PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_MEDIUM_STORE")
  field(SCAN, "I/O Intr")
}

###################################################################
#  These records support debugging                                #
#                                                                 #
###################################################################

record(longout, "BRICK1:REPORT_MEDIUM") {
  field(DESC, "Report the contents of medium store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_REPORT_MEDIUM")
}

record(longin, "BRICK1:SLOW_SIZE_RBV") {
  field(DESC, "Size of slow PMAC store")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_C_SLOW_STORE")
  field(SCAN, "I/O Intr")
}

record(longout, "BRICK1:REPORT_SLOW") {
  field(DESC, "Report the contents of slow store")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_REPORT_SLOW")
}

record(longout, "BRICK1:DEBUG_LEVEL"){
  field(DESC, "Set the debug level")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_DEBUG_LEVEL")
}

record(longout, "BRICK1:DEBUG_AXISNO"){
  field(DESC, "Debug which axis (0 is controller)")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_DEBUG_AXIS")
}

record(longout, "BRICK1:DEBUG_CSNO"){
  field(DESC, "Debug which CS (0 is main controller)")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_DEBUG_CS")
}

record(longout, "BRICK1:DEBUG_EXECUTE"){
  field(DESC, "Apply the debug settings")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_C_DEBUG_CMD")
}
# powerPmacStatus.template - device specific status PVs not compatible with PMAC
# % macro, PORT, The asyn port for the pmac controller
# % macro, P, PV Prefix

record(longin, "BRICK1:CALC_SERVO_FREQ") {
  field(DESC, "Servo Interrupt Time")
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_Sys.ServoPeriod")
  field(SCAN, "I/O Intr")
}

record(longin, "BRICK1:READ_ECHO") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VIS_ECHO")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS1:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS1:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#1P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS1:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#1F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS1:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#1V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS1:ReadBack") {
  field(LNK1, "BRICK1:AXIS1:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS1:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS1:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS1:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS1:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,1)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS1:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS1:status1") {
  field(INP, "BRICK1:AXIS1:READ_STAT1")
}

record(longin, "BRICK1:AXIS1:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,1)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS1:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS1:status2") {
  field(INP, "BRICK1:AXIS1:READ_STAT2")
}

record(longin, "BRICK1:AXIS1:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,1)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS1:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS1:status3") {
  field(INP, "BRICK1:AXIS1:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS2:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS2:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#2P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS2:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#2F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS2:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#2V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS2:ReadBack") {
  field(LNK1, "BRICK1:AXIS2:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS2:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS2:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS2:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS2:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,2)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS2:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS2:status1") {
  field(INP, "BRICK1:AXIS2:READ_STAT1")
}

record(longin, "BRICK1:AXIS2:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,2)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS2:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS2:status2") {
  field(INP, "BRICK1:AXIS2:READ_STAT2")
}

record(longin, "BRICK1:AXIS2:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,2)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS2:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS2:status3") {
  field(INP, "BRICK1:AXIS2:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS3:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS3:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#3P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS3:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#3F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS3:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#3V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS3:ReadBack") {
  field(LNK1, "BRICK1:AXIS3:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS3:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS3:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS3:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS3:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,3)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS3:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS3:status1") {
  field(INP, "BRICK1:AXIS3:READ_STAT1")
}

record(longin, "BRICK1:AXIS3:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,3)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS3:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS3:status2") {
  field(INP, "BRICK1:AXIS3:READ_STAT2")
}

record(longin, "BRICK1:AXIS3:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,3)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS3:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS3:status3") {
  field(INP, "BRICK1:AXIS3:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS4:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS4:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#4P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS4:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#4F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS4:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#4V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS4:ReadBack") {
  field(LNK1, "BRICK1:AXIS4:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS4:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS4:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS4:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS4:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,4)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS4:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS4:status1") {
  field(INP, "BRICK1:AXIS4:READ_STAT1")
}

record(longin, "BRICK1:AXIS4:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,4)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS4:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS4:status2") {
  field(INP, "BRICK1:AXIS4:READ_STAT2")
}

record(longin, "BRICK1:AXIS4:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,4)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS4:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS4:status3") {
  field(INP, "BRICK1:AXIS4:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS5:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS5:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#5P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS5:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#5F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS5:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#5V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS5:ReadBack") {
  field(LNK1, "BRICK1:AXIS5:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS5:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS5:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS5:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS5:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,5)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS5:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS5:status1") {
  field(INP, "BRICK1:AXIS5:READ_STAT1")
}

record(longin, "BRICK1:AXIS5:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,5)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS5:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS5:status2") {
  field(INP, "BRICK1:AXIS5:READ_STAT2")
}

record(longin, "BRICK1:AXIS5:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,5)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS5:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS5:status3") {
  field(INP, "BRICK1:AXIS5:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS6:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS6:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#6P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS6:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#6F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS6:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#6V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS6:ReadBack") {
  field(LNK1, "BRICK1:AXIS6:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS6:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS6:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS6:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS6:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,6)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS6:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS6:status1") {
  field(INP, "BRICK1:AXIS6:READ_STAT1")
}

record(longin, "BRICK1:AXIS6:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,6)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS6:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS6:status2") {
  field(INP, "BRICK1:AXIS6:READ_STAT2")
}

record(longin, "BRICK1:AXIS6:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,6)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS6:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS6:status3") {
  field(INP, "BRICK1:AXIS6:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS7:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS7:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#7P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS7:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#7F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS7:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#7V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS7:ReadBack") {
  field(LNK1, "BRICK1:AXIS7:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS7:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS7:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS7:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS7:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,7)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS7:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS7:status1") {
  field(INP, "BRICK1:AXIS7:READ_STAT1")
}

record(longin, "BRICK1:AXIS7:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,7)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS7:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS7:status2") {
  field(INP, "BRICK1:AXIS7:READ_STAT2")
}

record(longin, "BRICK1:AXIS7:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,7)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS7:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS7:status3") {
  field(INP, "BRICK1:AXIS7:READ_STAT3")
}
# % macro, PMAC,  Pmac/Geobrick name
# % macro, AXIS,    Axis number
# % macro, PORT,    Asyn port
record(stringout, "BRICK1:AXIS8:DESC") {
  field(PINI, "YES")
}

record(ai, "BRICK1:AXIS8:POSITION") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#8P")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS8:FOLL_ERROR") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#8F")
  field(PREC, "2")
}

record(ai, "BRICK1:AXIS8:VELOCITY") {
  field(DTYP, "asynFloat64")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#8V")
  field(PREC, "2")
}

record(seq, "BRICK1:AXIS8:ReadBack") {
  field(LNK1, "BRICK1:AXIS8:POSITION.PROC PP")
  field(LNK2, "BRICK1:AXIS8:FOLL_ERROR.PROC PP")
  field(LNK3, "BRICK1:AXIS8:VELOCITY.PROC PP")
  field(LNK4, "BRICK1:AXIS8:status1.PROC PP")
  field(DLY1, "0")
  field(DLY2, "0.5")
  field(DLY3, "0.5")
  field(DLY4, "0.5")
  field(DOL1, "1")
  field(DOL2, "1")
  field(DOL3, "1")
  field(DOL4, "1")
}

record(longin, "BRICK1:AXIS8:READ_STAT1") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,8)PMAC_C_AXIS_BITS01")
  field(FLNK, "BRICK1:AXIS8:status1")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS8:status1") {
  field(INP, "BRICK1:AXIS8:READ_STAT1")
}

record(longin, "BRICK1:AXIS8:READ_STAT2") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,8)PMAC_C_AXIS_BITS02")
  field(FLNK, "BRICK1:AXIS8:status2")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS8:status2") {
  field(INP, "BRICK1:AXIS8:READ_STAT2")
}

record(longin, "BRICK1:AXIS8:READ_STAT3") {
  field(DTYP, "asynInt32")
  field(SCAN, "I/O Intr")
  field(INP, "@asyn(Brick,8)PMAC_C_AXIS_BITS03")
  field(FLNK, "BRICK1:AXIS8:status3")
}

#% archiver 10 Monitor
record(mbbiDirect, "BRICK1:AXIS8:status3") {
  field(INP, "BRICK1:AXIS8:READ_STAT3")
}
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm1

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M1, edm, motor.edl, motor=BL:vm1
# % gui, BRICK1.MOTORS.M1, edmembed, motor-embed-small.edl, motor=BL:vm1,filename=motor.edl,box-label=Test motor

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M1, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:vm1,DESC=Test motor, name=BRICK1.MOTORS.M1
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:vm1,DESC=Test motor, name=BRICK1.MOTORS.M1
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:vm1,DESC=Test motor, name=BRICK1.MOTORS.M1
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:vm1

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M1, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M1, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M1, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M1, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M1, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M1, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M1, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M1, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M1, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M1, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M1, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M1, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M1, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M1, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M1, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M1, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M1, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M1, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M1, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M1, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M1, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M1, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M1, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M1, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M1, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M1, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M1, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M1, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M1, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M1, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M1, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M1, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M1, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M1, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M1, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M1, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M1, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M1, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M1, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M1, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M1, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M1, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M1, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M1, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M1, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M1, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M1, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M1, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M1, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M1, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M1, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M1, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M1, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M1, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M1, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M1, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M1, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:vm1")
{
	field(DESC,"Test motor")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,1)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"")
	field(DLLM,"")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:vm1:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:vm1:ADDR") {
    field(PINI, "YES")
    field(VAL, "1")
}

# record that holds the PORT
record(stringout, "BL:vm1:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:vm1:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:vm1:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:vm1:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:vm1:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:vm1:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:vm1.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:vm1:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm1:ELOSS
record(ai, "BL:vm1:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:vm1:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:vm1:CHECK_SYNC") {
  field(INPA, "BL:vm1.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:vm1:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:vm1:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:vm1:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:vm1.RMP CP")
	field(INPB,"BL:vm1.REP NPP")
	field(INPC,"BL:vm1.MRES NPP")
	field(INPD,"BL:vm1.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:vm1:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm1:FERRORMAX
record(calc, "BL:vm1:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:vm1:FERROR.VAL")
	field(INPB,"BL:vm1:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:vm1:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:vm1:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:vm1:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:vm1:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:vm1:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:vm1, BRICK1:CS1:M1)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm2

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M2, edm, motor.edl, motor=BL:vm2
# % gui, BRICK1.MOTORS.M2, edmembed, motor-embed-small.edl, motor=BL:vm2,filename=motor.edl,box-label=Test motor

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M2, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:vm2,DESC=Test motor, name=BRICK1.MOTORS.M2
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:vm2,DESC=Test motor, name=BRICK1.MOTORS.M2
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:vm2,DESC=Test motor, name=BRICK1.MOTORS.M2
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:vm2

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M2, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M2, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M2, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M2, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M2, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M2, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M2, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M2, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M2, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M2, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M2, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M2, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M2, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M2, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M2, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M2, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M2, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M2, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M2, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M2, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M2, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M2, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M2, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M2, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M2, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M2, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M2, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M2, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M2, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M2, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M2, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M2, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M2, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M2, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M2, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M2, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M2, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M2, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M2, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M2, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M2, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M2, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M2, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M2, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M2, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M2, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M2, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M2, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M2, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M2, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M2, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M2, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M2, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M2, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M2, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M2, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M2, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:vm2")
{
	field(DESC,"Test motor")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,2)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"")
	field(DLLM,"")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:vm2:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:vm2:ADDR") {
    field(PINI, "YES")
    field(VAL, "2")
}

# record that holds the PORT
record(stringout, "BL:vm2:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:vm2:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:vm2:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:vm2:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:vm2:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:vm2:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:vm2.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:vm2:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm2:ELOSS
record(ai, "BL:vm2:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:vm2:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:vm2:CHECK_SYNC") {
  field(INPA, "BL:vm2.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:vm2:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:vm2:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:vm2:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:vm2.RMP CP")
	field(INPB,"BL:vm2.REP NPP")
	field(INPC,"BL:vm2.MRES NPP")
	field(INPD,"BL:vm2.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:vm2:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm2:FERRORMAX
record(calc, "BL:vm2:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:vm2:FERROR.VAL")
	field(INPB,"BL:vm2:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:vm2:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:vm2:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:vm2:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:vm2:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:vm2:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:vm2, BRICK1:CS1:M2)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm3

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M3, edm, motor.edl, motor=BL:vm3
# % gui, BRICK1.MOTORS.M3, edmembed, motor-embed-small.edl, motor=BL:vm3,filename=motor.edl,box-label=Test motor

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M3, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:vm3,DESC=Test motor, name=BRICK1.MOTORS.M3
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:vm3,DESC=Test motor, name=BRICK1.MOTORS.M3
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:vm3,DESC=Test motor, name=BRICK1.MOTORS.M3
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:vm3

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M3, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M3, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M3, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M3, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M3, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M3, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M3, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M3, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M3, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M3, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M3, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M3, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M3, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M3, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M3, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M3, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M3, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M3, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M3, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M3, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M3, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M3, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M3, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M3, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M3, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M3, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M3, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M3, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M3, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M3, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M3, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M3, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M3, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M3, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M3, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M3, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M3, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M3, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M3, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M3, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M3, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M3, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M3, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M3, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M3, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M3, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M3, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M3, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M3, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M3, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M3, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M3, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M3, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M3, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M3, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M3, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M3, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:vm3")
{
	field(DESC,"Test motor")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,3)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"")
	field(DLLM,"")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:vm3:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:vm3:ADDR") {
    field(PINI, "YES")
    field(VAL, "3")
}

# record that holds the PORT
record(stringout, "BL:vm3:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:vm3:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:vm3:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:vm3:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:vm3:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:vm3:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:vm3.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:vm3:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm3:ELOSS
record(ai, "BL:vm3:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:vm3:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:vm3:CHECK_SYNC") {
  field(INPA, "BL:vm3.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:vm3:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:vm3:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:vm3:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:vm3.RMP CP")
	field(INPB,"BL:vm3.REP NPP")
	field(INPC,"BL:vm3.MRES NPP")
	field(INPD,"BL:vm3.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:vm3:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm3:FERRORMAX
record(calc, "BL:vm3:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:vm3:FERROR.VAL")
	field(INPB,"BL:vm3:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:vm3:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:vm3:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:vm3:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:vm3:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:vm3:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:vm3, BRICK1:CS1:M3)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm5

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M5, edm, motor.edl, motor=BL:vm5
# % gui, BRICK1.MOTORS.M5, edmembed, motor-embed-small.edl, motor=BL:vm5,filename=motor.edl,box-label=Test motor

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M5, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:vm5,DESC=Test motor, name=BRICK1.MOTORS.M5
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:vm5,DESC=Test motor, name=BRICK1.MOTORS.M5
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:vm5,DESC=Test motor, name=BRICK1.MOTORS.M5
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:vm5

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M5, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M5, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M5, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M5, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M5, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M5, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M5, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M5, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M5, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M5, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M5, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M5, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M5, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M5, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M5, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M5, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M5, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M5, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M5, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M5, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M5, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M5, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M5, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M5, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M5, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M5, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M5, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M5, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M5, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M5, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M5, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M5, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M5, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M5, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M5, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M5, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M5, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M5, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M5, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M5, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M5, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M5, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M5, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M5, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M5, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M5, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M5, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M5, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M5, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M5, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M5, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M5, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M5, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M5, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M5, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M5, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M5, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:vm5")
{
	field(DESC,"Test motor")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,5)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"")
	field(DLLM,"")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:vm5:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:vm5:ADDR") {
    field(PINI, "YES")
    field(VAL, "5")
}

# record that holds the PORT
record(stringout, "BL:vm5:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:vm5:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:vm5:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:vm5:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:vm5:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:vm5:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:vm5.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:vm5:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm5:ELOSS
record(ai, "BL:vm5:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:vm5:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:vm5:CHECK_SYNC") {
  field(INPA, "BL:vm5.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:vm5:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:vm5:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:vm5:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:vm5.RMP CP")
	field(INPB,"BL:vm5.REP NPP")
	field(INPC,"BL:vm5.MRES NPP")
	field(INPD,"BL:vm5.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:vm5:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm5:FERRORMAX
record(calc, "BL:vm5:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:vm5:FERROR.VAL")
	field(INPB,"BL:vm5:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:vm5:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:vm5:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:vm5:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:vm5:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:vm5:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:vm5, BRICK1:CS1:M5)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm6

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M6, edm, motor.edl, motor=BL:vm6
# % gui, BRICK1.MOTORS.M6, edmembed, motor-embed-small.edl, motor=BL:vm6,filename=motor.edl,box-label=Test motor

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M6, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:vm6,DESC=Test motor, name=BRICK1.MOTORS.M6
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:vm6,DESC=Test motor, name=BRICK1.MOTORS.M6
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:vm6,DESC=Test motor, name=BRICK1.MOTORS.M6
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:vm6

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M6, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M6, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M6, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M6, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M6, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M6, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M6, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M6, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M6, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M6, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M6, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M6, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M6, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M6, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M6, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M6, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M6, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M6, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M6, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M6, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M6, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M6, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M6, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M6, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M6, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M6, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M6, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M6, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M6, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M6, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M6, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M6, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M6, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M6, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M6, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M6, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M6, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M6, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M6, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M6, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M6, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M6, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M6, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M6, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M6, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M6, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M6, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M6, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M6, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M6, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M6, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M6, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M6, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M6, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M6, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M6, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M6, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:vm6")
{
	field(DESC,"Test motor")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,6)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"")
	field(DLLM,"")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:vm6:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:vm6:ADDR") {
    field(PINI, "YES")
    field(VAL, "6")
}

# record that holds the PORT
record(stringout, "BL:vm6:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:vm6:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:vm6:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:vm6:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:vm6:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:vm6:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:vm6.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:vm6:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm6:ELOSS
record(ai, "BL:vm6:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:vm6:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:vm6:CHECK_SYNC") {
  field(INPA, "BL:vm6.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:vm6:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:vm6:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:vm6:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:vm6.RMP CP")
	field(INPB,"BL:vm6.REP NPP")
	field(INPC,"BL:vm6.MRES NPP")
	field(INPD,"BL:vm6.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:vm6:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:vm6:FERRORMAX
record(calc, "BL:vm6:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:vm6:FERROR.VAL")
	field(INPB,"BL:vm6:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:vm6:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:vm6:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:vm6:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:vm6:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:vm6:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:vm6, BRICK1:CS1:M6)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M7, edm, motor.edl, motor=BL:Gap
# % gui, BRICK1.MOTORS.M7, edmembed, motor-embed-small.edl, motor=BL:Gap,filename=motor.edl,box-label=Horizontal gap

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M7, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:Gap,DESC=Horizontal gap, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:Gap,DESC=Horizontal gap, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:Gap,DESC=Horizontal gap, name=BRICK1.MOTORS.M7
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:Gap

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M7, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M7, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M7, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M7, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M7, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M7, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M7, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M7, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M7, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M7, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M7, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M7, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M7, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M7, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M7, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M7, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M7, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M7, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M7, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M7, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M7, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M7, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M7, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M7, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M7, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M7, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M7, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M7, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M7, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M7, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M7, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M7, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M7, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M7, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M7, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M7, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M7, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M7, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M7, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M7, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M7, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M7, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M7, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M7, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M7, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M7, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M7, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M7, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M7, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M7, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M7, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M7, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M7, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M7, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M7, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:Gap")
{
	field(DESC,"Horizontal gap")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,7)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:Gap:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:Gap:ADDR") {
    field(PINI, "YES")
    field(VAL, "7")
}

# record that holds the PORT
record(stringout, "BL:Gap:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:Gap:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:Gap:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:Gap:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:Gap:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:Gap:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:Gap.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:Gap:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap:ELOSS
record(ai, "BL:Gap:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:Gap:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:Gap:CHECK_SYNC") {
  field(INPA, "BL:Gap.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:Gap:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:Gap:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:Gap:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:Gap.RMP CP")
	field(INPB,"BL:Gap.REP NPP")
	field(INPC,"BL:Gap.MRES NPP")
	field(INPD,"BL:Gap.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:Gap:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap:FERRORMAX
record(calc, "BL:Gap:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:Gap:FERROR.VAL")
	field(INPB,"BL:Gap:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:Gap:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:Gap:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:Gap:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:Gap:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:Gap:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:Gap, BRICK1:CS1:M7)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M8, edm, motor.edl, motor=BL:Offset
# % gui, BRICK1.MOTORS.M8, edmembed, motor-embed-small.edl, motor=BL:Offset,filename=motor.edl,box-label=Horizontal offset

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M8, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:Offset,DESC=Horizontal offset, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:Offset,DESC=Horizontal offset, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:Offset,DESC=Horizontal offset, name=BRICK1.MOTORS.M8
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:Offset

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M8, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M8, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M8, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M8, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M8, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M8, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M8, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M8, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M8, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M8, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M8, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M8, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M8, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M8, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M8, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M8, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M8, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M8, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M8, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M8, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M8, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M8, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M8, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M8, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M8, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M8, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M8, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M8, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M8, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M8, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M8, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M8, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M8, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M8, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M8, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M8, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M8, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M8, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M8, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M8, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M8, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M8, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M8, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M8, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M8, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M8, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M8, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M8, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M8, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M8, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M8, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M8, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M8, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M8, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M8, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:Offset")
{
	field(DESC,"Horizontal offset")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS1,8)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:Offset:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:Offset:ADDR") {
    field(PINI, "YES")
    field(VAL, "8")
}

# record that holds the PORT
record(stringout, "BL:Offset:PORT") {
    field(PINI, "YES")
    field(VAL, "CS1")
}

# record that holds the SCALE
record(ao, "BL:Offset:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:Offset:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:Offset:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:Offset:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:Offset:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:Offset.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:Offset:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset:ELOSS
record(ai, "BL:Offset:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:Offset:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:Offset:CHECK_SYNC") {
  field(INPA, "BL:Offset.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:Offset:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:Offset:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:Offset:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:Offset.RMP CP")
	field(INPB,"BL:Offset.REP NPP")
	field(INPC,"BL:Offset.MRES NPP")
	field(INPD,"BL:Offset.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:Offset:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset:FERRORMAX
record(calc, "BL:Offset:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:Offset:FERROR.VAL")
	field(INPB,"BL:Offset:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:Offset:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:Offset:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:Offset:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:Offset:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:Offset:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS1")
}

# add alias for standard CS axis name
alias(BL:Offset, BRICK1:CS1:M8)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M7, edm, motor.edl, motor=BL:Gap
# % gui, BRICK1.MOTORS.M7, edmembed, motor-embed-small.edl, motor=BL:Gap,filename=motor.edl,box-label=Vertical gap

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M7, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:Gap,DESC=Vertical gap, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:Gap,DESC=Vertical gap, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:Gap,DESC=Vertical gap, name=BRICK1.MOTORS.M7
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:Gap

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M7, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M7, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M7, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M7, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M7, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M7, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M7, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M7, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M7, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M7, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M7, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M7, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M7, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M7, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M7, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M7, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M7, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M7, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M7, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M7, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M7, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M7, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M7, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M7, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M7, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M7, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M7, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M7, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M7, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M7, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M7, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M7, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M7, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M7, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M7, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M7, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M7, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M7, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M7, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M7, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M7, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M7, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M7, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M7, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M7, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M7, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M7, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M7, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M7, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M7, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M7, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M7, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M7, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M7, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M7, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:Gap")
{
	field(DESC,"Vertical gap")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS2,7)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:Gap:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:Gap:ADDR") {
    field(PINI, "YES")
    field(VAL, "7")
}

# record that holds the PORT
record(stringout, "BL:Gap:PORT") {
    field(PINI, "YES")
    field(VAL, "CS2")
}

# record that holds the SCALE
record(ao, "BL:Gap:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:Gap:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:Gap:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:Gap:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:Gap:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:Gap.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:Gap:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap:ELOSS
record(ai, "BL:Gap:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:Gap:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:Gap:CHECK_SYNC") {
  field(INPA, "BL:Gap.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:Gap:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:Gap:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:Gap:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:Gap.RMP CP")
	field(INPB,"BL:Gap.REP NPP")
	field(INPC,"BL:Gap.MRES NPP")
	field(INPD,"BL:Gap.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:Gap:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Gap:FERRORMAX
record(calc, "BL:Gap:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:Gap:FERROR.VAL")
	field(INPB,"BL:Gap:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:Gap:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:Gap:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:Gap:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:Gap:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:Gap:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS2")
}

# add alias for standard CS axis name
alias(BL:Gap, BRICK1:CS2:M7)
# A Coordinate system axis.

# macros listed here are those not described in basic_asyn_motor.template
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)
# % macro, CS, The CS num for this axis (must match CS in pmacCsController.template)

#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M8, edm, motor.edl, motor=BL:Offset
# % gui, BRICK1.MOTORS.M8, edmembed, motor-embed-small.edl, motor=BL:Offset,filename=motor.edl,box-label=Vertical offset

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M8, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:Offset,DESC=Vertical offset, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:Offset,DESC=Vertical offset, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:Offset,DESC=Vertical offset, name=BRICK1.MOTORS.M8
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:Offset

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M8, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M8, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M8, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M8, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M8, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M8, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M8, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M8, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M8, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M8, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M8, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M8, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M8, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M8, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M8, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M8, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M8, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M8, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M8, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M8, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M8, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M8, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M8, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M8, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M8, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M8, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M8, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M8, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M8, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M8, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M8, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M8, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M8, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M8, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M8, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M8, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M8, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M8, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M8, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M8, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M8, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M8, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M8, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M8, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M8, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M8, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M8, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M8, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M8, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M8, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M8, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M8, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M8, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M8, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M8, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:Offset")
{
	field(DESC,"Vertical offset")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(CS2,8)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "0.0")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:Offset:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:Offset:ADDR") {
    field(PINI, "YES")
    field(VAL, "8")
}

# record that holds the PORT
record(stringout, "BL:Offset:PORT") {
    field(PINI, "YES")
    field(VAL, "CS2")
}

# record that holds the SCALE
record(ao, "BL:Offset:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:Offset:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:Offset:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:Offset:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:Offset:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:Offset.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:Offset:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset:ELOSS
record(ai, "BL:Offset:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:Offset:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:Offset:CHECK_SYNC") {
  field(INPA, "BL:Offset.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:Offset:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:Offset:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:Offset:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:Offset.RMP CP")
	field(INPB,"BL:Offset.REP NPP")
	field(INPC,"BL:Offset.MRES NPP")
	field(INPD,"BL:Offset.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:Offset:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:Offset:FERRORMAX
record(calc, "BL:Offset:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:Offset:FERROR.VAL")
	field(INPB,"BL:Offset:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:Offset:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:Offset:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:Offset:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:Offset:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


record(stringin, "BL:Offset:CS_PORT_NAME") {
  field(DESC, "Port name for CS")
  field(VAL, "CS2")
}

# add alias for standard CS axis name
alias(BL:Offset, BRICK1:CS2:M8)
# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m1, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m1

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M1, edm, motor.edl, motor=BL:m1
# % gui, BRICK1.MOTORS.M1, edmembed, motor-embed-small.edl, motor=BL:m1,filename=motor.edl,box-label=Right

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M1, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m1,DESC=Right, name=BRICK1.MOTORS.M1
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m1,DESC=Right, name=BRICK1.MOTORS.M1
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m1,DESC=Right, name=BRICK1.MOTORS.M1
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M1, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m1

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M1, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M1, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M1, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M1, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M1, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M1, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M1, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M1, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M1, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M1, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M1, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M1, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M1, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M1, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M1, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M1, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M1, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M1, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M1, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M1, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M1, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M1, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M1, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M1, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M1, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M1, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M1, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M1, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M1, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M1, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M1, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M1, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M1, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M1, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M1, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M1, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M1, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M1, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M1, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M1, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M1, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M1, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M1, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M1, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M1, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M1, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M1, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M1, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M1, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M1, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M1, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M1, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M1, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M1, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M1, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M1, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M1, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m1")
{
	field(DESC,"Right")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,1)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m1:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m1:ADDR") {
    field(PINI, "YES")
    field(VAL, "1")
}

# record that holds the PORT
record(stringout, "BL:m1:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m1:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m1:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m1:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m1:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m1:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m1.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m1:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m1:ELOSS
record(ai, "BL:m1:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m1:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m1:CHECK_SYNC") {
  field(INPA, "BL:m1.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m1:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m1:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m1:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m1.RMP CP")
	field(INPB,"BL:m1.REP NPP")
	field(INPC,"BL:m1.MRES NPP")
	field(INPD,"BL:m1.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m1:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m1:FERRORMAX
record(calc, "BL:m1:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m1:FERROR.VAL")
	field(INPB,"BL:m1:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:m1:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m1:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m1:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m1:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m1, BRICK1:M1)
alias(BL:m1:ADDR, BRICK1:M1:ADDR)
alias(BL:m1:PORT, BRICK1:M1:PORT)
alias(BL:m1:SCALE, BRICK1:M1:SCALE)
alias(BL:m1:USER:SDIS, BRICK1M1:USER:SDIS)
alias(BL:m1:SDIS, BRICK1:M1:SDIS)
alias(BL:m1:KILL, BRICK1:M1:KILL)
alias(BL:m1:ELOSS, BRICK1:M1:ELOSS)
alias(BL:m1:ELOSSRC, BRICK1:M1:ELOSSRC)
alias(BL:m1:MR_MOVE_WRITE, BRICK1:M1:MR_MOVE_WRITE)
alias(BL:m1:CHECK_SYNC, BRICK1:M1:CHECK_SYNC)
alias(BL:m1:FERROR, BRICK1:M1:FERROR)
alias(BL:m1:FERRORMAX, BRICK1:M1:FERRORMAX)
alias(BL:m1:FEMAXRESET, BRICK1:M1:FEMAXRESET)
alias(BL:m1:HOMEVIS, BRICK1:M1:HOMEVIS)
alias(BL:m1:HOMEVISSTR, BRICK1:M1:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m1:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m1.MRES CP")
  field(INPB, "BL:m1.DIR CP")
  field(INPC, "BL:m1:SCALE")
  field(OUT, "BL:m1:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m1:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+1`")
  field(FLNK, "BL:m1:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m1:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m1.OFF CP")
  field(OUT, "BL:m1:OFF_SET PP")
}

record(ao, "BL:m1:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+1`")
  field(FLNK, "BL:m1:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m1:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,1)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m1:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,1)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m1:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,1)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m1:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,1)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m1:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,1)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m1:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m1:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m1:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m1:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m1:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m1:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m1:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,1)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m1:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#1P")
  field(DESC, "Right")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m1:HMPOS:CALC") {
  field(INPA, "BL:m1.MRES CP")
  field(INPB, "BL:m1:SCALE")  
  field(INPC, "BL:m1:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m1:HMPOS PP")
}

record(ai, "BL:m1:HMPOS") {
  field(DESC, "Right")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m1:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m1")
  field(OUT, "BL:HM:M1PV PP")
}

record(stringout, "BL:HM:M1PV"){
}

# define a kill record
record(ao, "BL:m1:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,1)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m1:ELOSSVAR") {
  field(CALC, "464+1")
  field(PINI, "YES")
}

record(ai, "BL:m1:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+1`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m1:ELOSSRC") {
  field(OUT, "BL:m1:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m1:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+1`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS1:DESC"){
  field(VAL, "Right")
}

#record(bo, "BL:m1:HOMED") {
#  field(DESC, "Set homed status for axis 1")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m1:HOMEDSET")
#}

#record(calcout, "BL:m1:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m1:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m145) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m1:DirectDemand")
{
    field(FLNK, "BL:m1:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m1:DirectCountsCalc")
{
    field(INPA, "BL:m1:DirectDemand")
    field(INPB, "BL:m1:Mres PP")
    field(INPC, "BL:m1:Offset PP")
    field(INPD, "BL:m1:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m1:RawDirectDemand PP")
}

record(ao, "BL:m1:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m1:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,1,4)MOTOR_MOVE_ABS")
    field(DESC, "Right")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m1:DirectMotorSeq")
{
    field(LNK1, "BL:m1:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m1:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,1,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m1:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,1,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m1:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,1,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m1:MresSource")
}

record(scalcout, BL:m1:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m1:Mres.INPA CA")
    field(FLNK, "BL:m1:OffsetSource")
}

record(scalcout, "BL:m1:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m1:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m1:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,1,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m1:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m1:Offset.INPA CA")
}


record(scalcout, BL:m1:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m1:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m1:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,1,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M1"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m1:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m1.MRES CP")
  field(INPB, "BL:m1.DIR CP")
  field(INPC, "BL:m1:SCALE")
  field(OUT, "BL:m1:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m1:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+1`")
  field(FLNK, "BL:m1:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m1:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m1.OFF CP")
  field(OUT, "BL:m1:OFF_SET PP")
}

record(ao, "BL:m1:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+1`")
  field(FLNK, "BL:m1:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m1:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,1)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m1:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,1)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m1:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,1)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m1:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,1)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m1:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,1)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m1:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m1:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m1:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m1:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m1:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m1:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m1:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,1)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m1:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#1P")
  field(DESC, "Right")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m1:HMPOS:CALC") {
  field(INPA, "BL:m1.MRES CP")
  field(INPB, "BL:m1:SCALE")  
  field(INPC, "BL:m1:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m1:HMPOS PP")
}

record(ai, "BL:m1:HMPOS") {
  field(DESC, "Right")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m1:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m1")
  field(OUT, "BL:HM:M1PV PP")
}

record(stringout, "BL:HM:M1PV"){
}

# define a kill record
record(ao, "BL:m1:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,1)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m1:ELOSSVAR") {
  field(CALC, "464+1")
  field(PINI, "YES")
}

record(ai, "BL:m1:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+1`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m1:ELOSSRC") {
  field(OUT, "BL:m1:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m1:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+1`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS1:DESC"){
  field(VAL, "Right")
}

#record(bo, "BL:m1:HOMED") {
#  field(DESC, "Set homed status for axis 1")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m1:HOMEDSET")
#}

#record(calcout, "BL:m1:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m1:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m145) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m1:DirectDemand")
{
    field(FLNK, "BL:m1:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m1:DirectCountsCalc")
{
    field(INPA, "BL:m1:DirectDemand")
    field(INPB, "BL:m1:Mres PP")
    field(INPC, "BL:m1:Offset PP")
    field(INPD, "BL:m1:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m1:RawDirectDemand PP")
}

record(ao, "BL:m1:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m1:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,1,4)MOTOR_MOVE_ABS")
    field(DESC, "Right")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m1:DirectMotorSeq")
{
    field(LNK1, "BL:m1:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m1:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,1,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m1:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,1,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m1:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,1,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m1:MresSource")
}

record(scalcout, BL:m1:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m1:Mres.INPA CA")
    field(FLNK, "BL:m1:OffsetSource")
}

record(scalcout, "BL:m1:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m1:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m1:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,1,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m1:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m1:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m1:Offset.INPA CA")
}


record(scalcout, BL:m1:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m1:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m1:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,1,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m2, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m2

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M2, edm, motor.edl, motor=BL:m2
# % gui, BRICK1.MOTORS.M2, edmembed, motor-embed-small.edl, motor=BL:m2,filename=motor.edl,box-label=Left

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M2, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m2,DESC=Left, name=BRICK1.MOTORS.M2
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m2,DESC=Left, name=BRICK1.MOTORS.M2
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m2,DESC=Left, name=BRICK1.MOTORS.M2
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M2, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m2

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M2, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M2, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M2, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M2, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M2, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M2, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M2, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M2, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M2, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M2, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M2, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M2, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M2, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M2, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M2, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M2, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M2, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M2, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M2, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M2, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M2, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M2, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M2, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M2, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M2, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M2, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M2, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M2, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M2, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M2, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M2, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M2, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M2, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M2, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M2, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M2, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M2, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M2, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M2, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M2, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M2, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M2, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M2, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M2, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M2, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M2, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M2, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M2, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M2, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M2, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M2, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M2, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M2, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M2, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M2, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M2, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M2, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m2")
{
	field(DESC,"Left")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,2)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m2:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m2:ADDR") {
    field(PINI, "YES")
    field(VAL, "2")
}

# record that holds the PORT
record(stringout, "BL:m2:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m2:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m2:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m2:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m2:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m2:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m2.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m2:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m2:ELOSS
record(ai, "BL:m2:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m2:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m2:CHECK_SYNC") {
  field(INPA, "BL:m2.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m2:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m2:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m2:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m2.RMP CP")
	field(INPB,"BL:m2.REP NPP")
	field(INPC,"BL:m2.MRES NPP")
	field(INPD,"BL:m2.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m2:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m2:FERRORMAX
record(calc, "BL:m2:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m2:FERROR.VAL")
	field(INPB,"BL:m2:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:m2:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m2:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m2:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m2:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m2, BRICK1:M2)
alias(BL:m2:ADDR, BRICK1:M2:ADDR)
alias(BL:m2:PORT, BRICK1:M2:PORT)
alias(BL:m2:SCALE, BRICK1:M2:SCALE)
alias(BL:m2:USER:SDIS, BRICK1M2:USER:SDIS)
alias(BL:m2:SDIS, BRICK1:M2:SDIS)
alias(BL:m2:KILL, BRICK1:M2:KILL)
alias(BL:m2:ELOSS, BRICK1:M2:ELOSS)
alias(BL:m2:ELOSSRC, BRICK1:M2:ELOSSRC)
alias(BL:m2:MR_MOVE_WRITE, BRICK1:M2:MR_MOVE_WRITE)
alias(BL:m2:CHECK_SYNC, BRICK1:M2:CHECK_SYNC)
alias(BL:m2:FERROR, BRICK1:M2:FERROR)
alias(BL:m2:FERRORMAX, BRICK1:M2:FERRORMAX)
alias(BL:m2:FEMAXRESET, BRICK1:M2:FEMAXRESET)
alias(BL:m2:HOMEVIS, BRICK1:M2:HOMEVIS)
alias(BL:m2:HOMEVISSTR, BRICK1:M2:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m2:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m2.MRES CP")
  field(INPB, "BL:m2.DIR CP")
  field(INPC, "BL:m2:SCALE")
  field(OUT, "BL:m2:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m2:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+2`")
  field(FLNK, "BL:m2:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m2:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m2.OFF CP")
  field(OUT, "BL:m2:OFF_SET PP")
}

record(ao, "BL:m2:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+2`")
  field(FLNK, "BL:m2:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m2:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,2)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m2:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,2)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m2:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,2)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m2:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,2)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m2:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,2)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m2:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m2:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m2:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m2:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m2:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m2:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m2:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,2)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m2:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#2P")
  field(DESC, "Left")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m2:HMPOS:CALC") {
  field(INPA, "BL:m2.MRES CP")
  field(INPB, "BL:m2:SCALE")  
  field(INPC, "BL:m2:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m2:HMPOS PP")
}

record(ai, "BL:m2:HMPOS") {
  field(DESC, "Left")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m2:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m2")
  field(OUT, "BL:HM:M2PV PP")
}

record(stringout, "BL:HM:M2PV"){
}

# define a kill record
record(ao, "BL:m2:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,2)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m2:ELOSSVAR") {
  field(CALC, "464+2")
  field(PINI, "YES")
}

record(ai, "BL:m2:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+2`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m2:ELOSSRC") {
  field(OUT, "BL:m2:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m2:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+2`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS2:DESC"){
  field(VAL, "Left")
}

#record(bo, "BL:m2:HOMED") {
#  field(DESC, "Set homed status for axis 2")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m2:HOMEDSET")
#}

#record(calcout, "BL:m2:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m2:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m245) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m2:DirectDemand")
{
    field(FLNK, "BL:m2:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m2:DirectCountsCalc")
{
    field(INPA, "BL:m2:DirectDemand")
    field(INPB, "BL:m2:Mres PP")
    field(INPC, "BL:m2:Offset PP")
    field(INPD, "BL:m2:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m2:RawDirectDemand PP")
}

record(ao, "BL:m2:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m2:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,2,4)MOTOR_MOVE_ABS")
    field(DESC, "Left")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m2:DirectMotorSeq")
{
    field(LNK1, "BL:m2:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m2:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,2,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m2:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,2,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m2:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,2,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m2:MresSource")
}

record(scalcout, BL:m2:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m2:Mres.INPA CA")
    field(FLNK, "BL:m2:OffsetSource")
}

record(scalcout, "BL:m2:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m2:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m2:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,2,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m2:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m2:Offset.INPA CA")
}


record(scalcout, BL:m2:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m2:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m2:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,2,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M2"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m2:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m2.MRES CP")
  field(INPB, "BL:m2.DIR CP")
  field(INPC, "BL:m2:SCALE")
  field(OUT, "BL:m2:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m2:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+2`")
  field(FLNK, "BL:m2:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m2:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m2.OFF CP")
  field(OUT, "BL:m2:OFF_SET PP")
}

record(ao, "BL:m2:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+2`")
  field(FLNK, "BL:m2:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m2:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,2)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m2:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,2)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m2:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,2)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m2:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,2)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m2:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,2)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m2:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m2:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m2:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m2:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m2:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m2:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m2:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,2)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m2:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#2P")
  field(DESC, "Left")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m2:HMPOS:CALC") {
  field(INPA, "BL:m2.MRES CP")
  field(INPB, "BL:m2:SCALE")  
  field(INPC, "BL:m2:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m2:HMPOS PP")
}

record(ai, "BL:m2:HMPOS") {
  field(DESC, "Left")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m2:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m2")
  field(OUT, "BL:HM:M2PV PP")
}

record(stringout, "BL:HM:M2PV"){
}

# define a kill record
record(ao, "BL:m2:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,2)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m2:ELOSSVAR") {
  field(CALC, "464+2")
  field(PINI, "YES")
}

record(ai, "BL:m2:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+2`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m2:ELOSSRC") {
  field(OUT, "BL:m2:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m2:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+2`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS2:DESC"){
  field(VAL, "Left")
}

#record(bo, "BL:m2:HOMED") {
#  field(DESC, "Set homed status for axis 2")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m2:HOMEDSET")
#}

#record(calcout, "BL:m2:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m2:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m245) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m2:DirectDemand")
{
    field(FLNK, "BL:m2:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m2:DirectCountsCalc")
{
    field(INPA, "BL:m2:DirectDemand")
    field(INPB, "BL:m2:Mres PP")
    field(INPC, "BL:m2:Offset PP")
    field(INPD, "BL:m2:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m2:RawDirectDemand PP")
}

record(ao, "BL:m2:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m2:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,2,4)MOTOR_MOVE_ABS")
    field(DESC, "Left")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m2:DirectMotorSeq")
{
    field(LNK1, "BL:m2:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m2:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,2,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m2:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,2,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m2:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,2,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m2:MresSource")
}

record(scalcout, BL:m2:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m2:Mres.INPA CA")
    field(FLNK, "BL:m2:OffsetSource")
}

record(scalcout, "BL:m2:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m2:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m2:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,2,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m2:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m2:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m2:Offset.INPA CA")
}


record(scalcout, BL:m2:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m2:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m2:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,2,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m3, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m3

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M3, edm, motor.edl, motor=BL:m3
# % gui, BRICK1.MOTORS.M3, edmembed, motor-embed-small.edl, motor=BL:m3,filename=motor.edl,box-label=Top

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M3, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m3,DESC=Top, name=BRICK1.MOTORS.M3
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m3,DESC=Top, name=BRICK1.MOTORS.M3
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m3,DESC=Top, name=BRICK1.MOTORS.M3
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M3, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m3

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M3, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M3, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M3, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M3, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M3, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M3, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M3, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M3, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M3, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M3, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M3, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M3, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M3, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M3, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M3, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M3, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M3, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M3, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M3, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M3, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M3, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M3, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M3, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M3, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M3, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M3, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M3, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M3, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M3, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M3, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M3, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M3, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M3, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M3, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M3, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M3, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M3, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M3, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M3, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M3, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M3, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M3, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M3, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M3, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M3, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M3, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M3, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M3, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M3, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M3, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M3, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M3, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M3, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M3, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M3, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M3, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M3, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m3")
{
	field(DESC,"Top")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,3)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m3:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m3:ADDR") {
    field(PINI, "YES")
    field(VAL, "3")
}

# record that holds the PORT
record(stringout, "BL:m3:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m3:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m3:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m3:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m3:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m3:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m3.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m3:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m3:ELOSS
record(ai, "BL:m3:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m3:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m3:CHECK_SYNC") {
  field(INPA, "BL:m3.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m3:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m3:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m3:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m3.RMP CP")
	field(INPB,"BL:m3.REP NPP")
	field(INPC,"BL:m3.MRES NPP")
	field(INPD,"BL:m3.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m3:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m3:FERRORMAX
record(calc, "BL:m3:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m3:FERROR.VAL")
	field(INPB,"BL:m3:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:m3:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m3:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m3:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m3:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m3, BRICK1:M3)
alias(BL:m3:ADDR, BRICK1:M3:ADDR)
alias(BL:m3:PORT, BRICK1:M3:PORT)
alias(BL:m3:SCALE, BRICK1:M3:SCALE)
alias(BL:m3:USER:SDIS, BRICK1M3:USER:SDIS)
alias(BL:m3:SDIS, BRICK1:M3:SDIS)
alias(BL:m3:KILL, BRICK1:M3:KILL)
alias(BL:m3:ELOSS, BRICK1:M3:ELOSS)
alias(BL:m3:ELOSSRC, BRICK1:M3:ELOSSRC)
alias(BL:m3:MR_MOVE_WRITE, BRICK1:M3:MR_MOVE_WRITE)
alias(BL:m3:CHECK_SYNC, BRICK1:M3:CHECK_SYNC)
alias(BL:m3:FERROR, BRICK1:M3:FERROR)
alias(BL:m3:FERRORMAX, BRICK1:M3:FERRORMAX)
alias(BL:m3:FEMAXRESET, BRICK1:M3:FEMAXRESET)
alias(BL:m3:HOMEVIS, BRICK1:M3:HOMEVIS)
alias(BL:m3:HOMEVISSTR, BRICK1:M3:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m3:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m3.MRES CP")
  field(INPB, "BL:m3.DIR CP")
  field(INPC, "BL:m3:SCALE")
  field(OUT, "BL:m3:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m3:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+3`")
  field(FLNK, "BL:m3:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m3:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m3.OFF CP")
  field(OUT, "BL:m3:OFF_SET PP")
}

record(ao, "BL:m3:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+3`")
  field(FLNK, "BL:m3:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m3:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,3)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m3:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,3)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m3:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,3)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m3:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,3)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m3:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,3)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m3:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m3:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m3:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m3:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m3:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m3:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m3:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,3)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m3:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#3P")
  field(DESC, "Top")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m3:HMPOS:CALC") {
  field(INPA, "BL:m3.MRES CP")
  field(INPB, "BL:m3:SCALE")  
  field(INPC, "BL:m3:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m3:HMPOS PP")
}

record(ai, "BL:m3:HMPOS") {
  field(DESC, "Top")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m3:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m3")
  field(OUT, "BL:HM:M3PV PP")
}

record(stringout, "BL:HM:M3PV"){
}

# define a kill record
record(ao, "BL:m3:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,3)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m3:ELOSSVAR") {
  field(CALC, "464+3")
  field(PINI, "YES")
}

record(ai, "BL:m3:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+3`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m3:ELOSSRC") {
  field(OUT, "BL:m3:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m3:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+3`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS3:DESC"){
  field(VAL, "Top")
}

#record(bo, "BL:m3:HOMED") {
#  field(DESC, "Set homed status for axis 3")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m3:HOMEDSET")
#}

#record(calcout, "BL:m3:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m3:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m345) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m3:DirectDemand")
{
    field(FLNK, "BL:m3:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m3:DirectCountsCalc")
{
    field(INPA, "BL:m3:DirectDemand")
    field(INPB, "BL:m3:Mres PP")
    field(INPC, "BL:m3:Offset PP")
    field(INPD, "BL:m3:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m3:RawDirectDemand PP")
}

record(ao, "BL:m3:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m3:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,3,4)MOTOR_MOVE_ABS")
    field(DESC, "Top")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m3:DirectMotorSeq")
{
    field(LNK1, "BL:m3:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m3:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m3:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m3:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m3:MresSource")
}

record(scalcout, BL:m3:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m3:Mres.INPA CA")
    field(FLNK, "BL:m3:OffsetSource")
}

record(scalcout, "BL:m3:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m3:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m3:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m3:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m3:Offset.INPA CA")
}


record(scalcout, BL:m3:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m3:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m3:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,3,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M3"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m3:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m3.MRES CP")
  field(INPB, "BL:m3.DIR CP")
  field(INPC, "BL:m3:SCALE")
  field(OUT, "BL:m3:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m3:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+3`")
  field(FLNK, "BL:m3:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m3:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m3.OFF CP")
  field(OUT, "BL:m3:OFF_SET PP")
}

record(ao, "BL:m3:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+3`")
  field(FLNK, "BL:m3:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m3:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,3)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m3:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,3)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m3:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,3)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m3:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,3)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m3:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,3)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m3:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m3:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m3:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m3:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m3:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m3:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m3:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,3)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m3:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#3P")
  field(DESC, "Top")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m3:HMPOS:CALC") {
  field(INPA, "BL:m3.MRES CP")
  field(INPB, "BL:m3:SCALE")  
  field(INPC, "BL:m3:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m3:HMPOS PP")
}

record(ai, "BL:m3:HMPOS") {
  field(DESC, "Top")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m3:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m3")
  field(OUT, "BL:HM:M3PV PP")
}

record(stringout, "BL:HM:M3PV"){
}

# define a kill record
record(ao, "BL:m3:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,3)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m3:ELOSSVAR") {
  field(CALC, "464+3")
  field(PINI, "YES")
}

record(ai, "BL:m3:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+3`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m3:ELOSSRC") {
  field(OUT, "BL:m3:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m3:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+3`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS3:DESC"){
  field(VAL, "Top")
}

#record(bo, "BL:m3:HOMED") {
#  field(DESC, "Set homed status for axis 3")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m3:HOMEDSET")
#}

#record(calcout, "BL:m3:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m3:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m345) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m3:DirectDemand")
{
    field(FLNK, "BL:m3:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m3:DirectCountsCalc")
{
    field(INPA, "BL:m3:DirectDemand")
    field(INPB, "BL:m3:Mres PP")
    field(INPC, "BL:m3:Offset PP")
    field(INPD, "BL:m3:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m3:RawDirectDemand PP")
}

record(ao, "BL:m3:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m3:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,3,4)MOTOR_MOVE_ABS")
    field(DESC, "Top")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m3:DirectMotorSeq")
{
    field(LNK1, "BL:m3:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m3:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,3,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m3:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,3,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m3:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,3,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m3:MresSource")
}

record(scalcout, BL:m3:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m3:Mres.INPA CA")
    field(FLNK, "BL:m3:OffsetSource")
}

record(scalcout, "BL:m3:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m3:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m3:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,3,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m3:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m3:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m3:Offset.INPA CA")
}


record(scalcout, BL:m3:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m3:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m3:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,3,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m4, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m4

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M4, edm, motor.edl, motor=BL:m4
# % gui, BRICK1.MOTORS.M4, edmembed, motor-embed-small.edl, motor=BL:m4,filename=motor.edl,box-label=Bottom

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M4, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m4,DESC=Bottom, name=BRICK1.MOTORS.M4
# % gui, BRICK1.MOTORS.M4, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m4,DESC=Bottom, name=BRICK1.MOTORS.M4
# % gui, BRICK1.MOTORS.M4, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m4,DESC=Bottom, name=BRICK1.MOTORS.M4
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M4, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m4

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M4, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M4, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M4, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M4, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M4, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M4, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M4, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M4, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M4, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M4, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M4, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M4, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M4, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M4, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M4, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M4, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M4, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M4, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M4, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M4, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M4, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M4, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M4, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M4, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M4, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M4, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M4, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M4, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M4, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M4, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M4, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M4, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M4, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M4, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M4, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M4, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M4, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M4, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M4, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M4, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M4, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M4, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M4, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M4, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M4, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M4, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M4, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M4, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M4, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M4, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M4, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M4, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M4, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M4, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M4, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M4, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M4, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m4")
{
	field(DESC,"Bottom")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"10")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,4)")
	field(MRES,"0.048828125")
	field(PREC,"3")
	field(EGU,"um")
	field(DHLM,"10000")
	field(DLLM,"-10000")
	field(HLM,"10000")
	field(LLM,"-10000")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "8192")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "10")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m4:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m4:ADDR") {
    field(PINI, "YES")
    field(VAL, "4")
}

# record that holds the PORT
record(stringout, "BL:m4:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m4:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m4:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m4:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m4:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m4:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m4.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m4:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m4:ELOSS
record(ai, "BL:m4:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m4:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m4:CHECK_SYNC") {
  field(INPA, "BL:m4.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m4:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m4:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m4:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m4.RMP CP")
	field(INPB,"BL:m4.REP NPP")
	field(INPC,"BL:m4.MRES NPP")
	field(INPD,"BL:m4.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m4:FERRORMAX")
	field(PREC,"3")
	field(EGU, "um")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m4:FERRORMAX
record(calc, "BL:m4:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m4:FERROR.VAL")
	field(INPB,"BL:m4:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "um")
}	

#Record to reset the maximum following error
record(bo, "BL:m4:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m4:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m4:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m4:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m4, BRICK1:M4)
alias(BL:m4:ADDR, BRICK1:M4:ADDR)
alias(BL:m4:PORT, BRICK1:M4:PORT)
alias(BL:m4:SCALE, BRICK1:M4:SCALE)
alias(BL:m4:USER:SDIS, BRICK1M4:USER:SDIS)
alias(BL:m4:SDIS, BRICK1:M4:SDIS)
alias(BL:m4:KILL, BRICK1:M4:KILL)
alias(BL:m4:ELOSS, BRICK1:M4:ELOSS)
alias(BL:m4:ELOSSRC, BRICK1:M4:ELOSSRC)
alias(BL:m4:MR_MOVE_WRITE, BRICK1:M4:MR_MOVE_WRITE)
alias(BL:m4:CHECK_SYNC, BRICK1:M4:CHECK_SYNC)
alias(BL:m4:FERROR, BRICK1:M4:FERROR)
alias(BL:m4:FERRORMAX, BRICK1:M4:FERRORMAX)
alias(BL:m4:FEMAXRESET, BRICK1:M4:FEMAXRESET)
alias(BL:m4:HOMEVIS, BRICK1:M4:HOMEVIS)
alias(BL:m4:HOMEVISSTR, BRICK1:M4:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m4:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m4.MRES CP")
  field(INPB, "BL:m4.DIR CP")
  field(INPC, "BL:m4:SCALE")
  field(OUT, "BL:m4:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m4:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+4`")
  field(FLNK, "BL:m4:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m4:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m4.OFF CP")
  field(OUT, "BL:m4:OFF_SET PP")
}

record(ao, "BL:m4:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+4`")
  field(FLNK, "BL:m4:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m4:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,4)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m4:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,4)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m4:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,4)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m4:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,4)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m4:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,4)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m4:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m4:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m4:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m4:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m4:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m4:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m4:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,4)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m4:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#4P")
  field(DESC, "Bottom")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m4:HMPOS:CALC") {
  field(INPA, "BL:m4.MRES CP")
  field(INPB, "BL:m4:SCALE")  
  field(INPC, "BL:m4:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m4:HMPOS PP")
}

record(ai, "BL:m4:HMPOS") {
  field(DESC, "Bottom")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m4:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m4")
  field(OUT, "BL:HM:M4PV PP")
}

record(stringout, "BL:HM:M4PV"){
}

# define a kill record
record(ao, "BL:m4:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,4)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m4:ELOSSVAR") {
  field(CALC, "464+4")
  field(PINI, "YES")
}

record(ai, "BL:m4:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+4`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m4:ELOSSRC") {
  field(OUT, "BL:m4:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m4:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+4`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS4:DESC"){
  field(VAL, "Bottom")
}

#record(bo, "BL:m4:HOMED") {
#  field(DESC, "Set homed status for axis 4")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m4:HOMEDSET")
#}

#record(calcout, "BL:m4:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m4:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m445) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m4:DirectDemand")
{
    field(FLNK, "BL:m4:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m4:DirectCountsCalc")
{
    field(INPA, "BL:m4:DirectDemand")
    field(INPB, "BL:m4:Mres PP")
    field(INPC, "BL:m4:Offset PP")
    field(INPD, "BL:m4:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m4:RawDirectDemand PP")
}

record(ao, "BL:m4:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m4:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,4,4)MOTOR_MOVE_ABS")
    field(DESC, "Bottom")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m4:DirectMotorSeq")
{
    field(LNK1, "BL:m4:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m4:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m4:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m4:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m4:MresSource")
}

record(scalcout, BL:m4:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m4:Mres.INPA CA")
    field(FLNK, "BL:m4:OffsetSource")
}

record(scalcout, "BL:m4:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m4:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m4:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m4:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m4:Offset.INPA CA")
}


record(scalcout, BL:m4:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m4:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m4:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,4,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M4"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m4:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m4.MRES CP")
  field(INPB, "BL:m4.DIR CP")
  field(INPC, "BL:m4:SCALE")
  field(OUT, "BL:m4:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m4:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+4`")
  field(FLNK, "BL:m4:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m4:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m4.OFF CP")
  field(OUT, "BL:m4:OFF_SET PP")
}

record(ao, "BL:m4:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+4`")
  field(FLNK, "BL:m4:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m4:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,4)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m4:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,4)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m4:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,4)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m4:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,4)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m4:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,4)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m4:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m4:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m4:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m4:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m4:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m4:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m4:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,4)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m4:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#4P")
  field(DESC, "Bottom")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "um")
}

record(calcout, "BL:m4:HMPOS:CALC") {
  field(INPA, "BL:m4.MRES CP")
  field(INPB, "BL:m4:SCALE")  
  field(INPC, "BL:m4:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m4:HMPOS PP")
}

record(ai, "BL:m4:HMPOS") {
  field(DESC, "Bottom")
  field(PREC, "3")
  field(EGU, "um")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m4:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m4")
  field(OUT, "BL:HM:M4PV PP")
}

record(stringout, "BL:HM:M4PV"){
}

# define a kill record
record(ao, "BL:m4:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,4)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m4:ELOSSVAR") {
  field(CALC, "464+4")
  field(PINI, "YES")
}

record(ai, "BL:m4:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+4`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m4:ELOSSRC") {
  field(OUT, "BL:m4:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m4:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+4`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS4:DESC"){
  field(VAL, "Bottom")
}

#record(bo, "BL:m4:HOMED") {
#  field(DESC, "Set homed status for axis 4")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m4:HOMEDSET")
#}

#record(calcout, "BL:m4:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m4:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m445) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m4:DirectDemand")
{
    field(FLNK, "BL:m4:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m4:DirectCountsCalc")
{
    field(INPA, "BL:m4:DirectDemand")
    field(INPB, "BL:m4:Mres PP")
    field(INPC, "BL:m4:Offset PP")
    field(INPD, "BL:m4:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m4:RawDirectDemand PP")
}

record(ao, "BL:m4:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m4:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,4,4)MOTOR_MOVE_ABS")
    field(DESC, "Bottom")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m4:DirectMotorSeq")
{
    field(LNK1, "BL:m4:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m4:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,4,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m4:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,4,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m4:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,4,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m4:MresSource")
}

record(scalcout, BL:m4:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m4:Mres.INPA CA")
    field(FLNK, "BL:m4:OffsetSource")
}

record(scalcout, "BL:m4:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m4:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m4:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,4,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m4:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m4:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m4:Offset.INPA CA")
}


record(scalcout, BL:m4:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m4:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m4:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,4,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m5, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m5

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M5, edm, motor.edl, motor=BL:m5
# % gui, BRICK1.MOTORS.M5, edmembed, motor-embed-small.edl, motor=BL:m5,filename=motor.edl,box-label=Motor 5

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M5, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m5,DESC=Motor 5, name=BRICK1.MOTORS.M5
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m5,DESC=Motor 5, name=BRICK1.MOTORS.M5
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m5,DESC=Motor 5, name=BRICK1.MOTORS.M5
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M5, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m5

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M5, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M5, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M5, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M5, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M5, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M5, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M5, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M5, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M5, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M5, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M5, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M5, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M5, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M5, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M5, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M5, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M5, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M5, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M5, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M5, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M5, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M5, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M5, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M5, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M5, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M5, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M5, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M5, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M5, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M5, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M5, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M5, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M5, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M5, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M5, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M5, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M5, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M5, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M5, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M5, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M5, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M5, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M5, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M5, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M5, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M5, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M5, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M5, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M5, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M5, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M5, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M5, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M5, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M5, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M5, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M5, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M5, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m5")
{
	field(DESC,"Motor 5")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,5)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m5:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m5:ADDR") {
    field(PINI, "YES")
    field(VAL, "5")
}

# record that holds the PORT
record(stringout, "BL:m5:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m5:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m5:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m5:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m5:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m5:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m5.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m5:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m5:ELOSS
record(ai, "BL:m5:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m5:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m5:CHECK_SYNC") {
  field(INPA, "BL:m5.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m5:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m5:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m5:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m5.RMP CP")
	field(INPB,"BL:m5.REP NPP")
	field(INPC,"BL:m5.MRES NPP")
	field(INPD,"BL:m5.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m5:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m5:FERRORMAX
record(calc, "BL:m5:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m5:FERROR.VAL")
	field(INPB,"BL:m5:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:m5:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m5:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m5:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m5:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m5, BRICK1:M5)
alias(BL:m5:ADDR, BRICK1:M5:ADDR)
alias(BL:m5:PORT, BRICK1:M5:PORT)
alias(BL:m5:SCALE, BRICK1:M5:SCALE)
alias(BL:m5:USER:SDIS, BRICK1M5:USER:SDIS)
alias(BL:m5:SDIS, BRICK1:M5:SDIS)
alias(BL:m5:KILL, BRICK1:M5:KILL)
alias(BL:m5:ELOSS, BRICK1:M5:ELOSS)
alias(BL:m5:ELOSSRC, BRICK1:M5:ELOSSRC)
alias(BL:m5:MR_MOVE_WRITE, BRICK1:M5:MR_MOVE_WRITE)
alias(BL:m5:CHECK_SYNC, BRICK1:M5:CHECK_SYNC)
alias(BL:m5:FERROR, BRICK1:M5:FERROR)
alias(BL:m5:FERRORMAX, BRICK1:M5:FERRORMAX)
alias(BL:m5:FEMAXRESET, BRICK1:M5:FEMAXRESET)
alias(BL:m5:HOMEVIS, BRICK1:M5:HOMEVIS)
alias(BL:m5:HOMEVISSTR, BRICK1:M5:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m5:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m5.MRES CP")
  field(INPB, "BL:m5.DIR CP")
  field(INPC, "BL:m5:SCALE")
  field(OUT, "BL:m5:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m5:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+5`")
  field(FLNK, "BL:m5:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m5:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m5.OFF CP")
  field(OUT, "BL:m5:OFF_SET PP")
}

record(ao, "BL:m5:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+5`")
  field(FLNK, "BL:m5:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m5:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,5)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m5:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,5)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m5:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,5)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m5:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,5)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m5:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,5)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m5:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m5:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m5:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m5:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m5:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m5:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m5:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,5)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m5:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#5P")
  field(DESC, "Motor 5")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m5:HMPOS:CALC") {
  field(INPA, "BL:m5.MRES CP")
  field(INPB, "BL:m5:SCALE")  
  field(INPC, "BL:m5:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m5:HMPOS PP")
}

record(ai, "BL:m5:HMPOS") {
  field(DESC, "Motor 5")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m5:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m5")
  field(OUT, "BL:HM:M5PV PP")
}

record(stringout, "BL:HM:M5PV"){
}

# define a kill record
record(ao, "BL:m5:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,5)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m5:ELOSSVAR") {
  field(CALC, "464+5")
  field(PINI, "YES")
}

record(ai, "BL:m5:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+5`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m5:ELOSSRC") {
  field(OUT, "BL:m5:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m5:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+5`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS5:DESC"){
  field(VAL, "Motor 5")
}

#record(bo, "BL:m5:HOMED") {
#  field(DESC, "Set homed status for axis 5")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m5:HOMEDSET")
#}

#record(calcout, "BL:m5:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m5:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m545) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m5:DirectDemand")
{
    field(FLNK, "BL:m5:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m5:DirectCountsCalc")
{
    field(INPA, "BL:m5:DirectDemand")
    field(INPB, "BL:m5:Mres PP")
    field(INPC, "BL:m5:Offset PP")
    field(INPD, "BL:m5:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m5:RawDirectDemand PP")
}

record(ao, "BL:m5:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m5:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,5,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 5")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m5:DirectMotorSeq")
{
    field(LNK1, "BL:m5:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m5:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m5:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m5:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m5:MresSource")
}

record(scalcout, BL:m5:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m5:Mres.INPA CA")
    field(FLNK, "BL:m5:OffsetSource")
}

record(scalcout, "BL:m5:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m5:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m5:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m5:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m5:Offset.INPA CA")
}


record(scalcout, BL:m5:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m5:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m5:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,5,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M5"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m5:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m5.MRES CP")
  field(INPB, "BL:m5.DIR CP")
  field(INPC, "BL:m5:SCALE")
  field(OUT, "BL:m5:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m5:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+5`")
  field(FLNK, "BL:m5:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m5:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m5.OFF CP")
  field(OUT, "BL:m5:OFF_SET PP")
}

record(ao, "BL:m5:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+5`")
  field(FLNK, "BL:m5:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m5:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,5)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m5:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,5)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m5:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,5)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m5:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,5)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m5:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,5)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m5:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m5:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m5:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m5:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m5:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m5:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m5:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,5)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m5:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#5P")
  field(DESC, "Motor 5")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m5:HMPOS:CALC") {
  field(INPA, "BL:m5.MRES CP")
  field(INPB, "BL:m5:SCALE")  
  field(INPC, "BL:m5:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m5:HMPOS PP")
}

record(ai, "BL:m5:HMPOS") {
  field(DESC, "Motor 5")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m5:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m5")
  field(OUT, "BL:HM:M5PV PP")
}

record(stringout, "BL:HM:M5PV"){
}

# define a kill record
record(ao, "BL:m5:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,5)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m5:ELOSSVAR") {
  field(CALC, "464+5")
  field(PINI, "YES")
}

record(ai, "BL:m5:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+5`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m5:ELOSSRC") {
  field(OUT, "BL:m5:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m5:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+5`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS5:DESC"){
  field(VAL, "Motor 5")
}

#record(bo, "BL:m5:HOMED") {
#  field(DESC, "Set homed status for axis 5")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m5:HOMEDSET")
#}

#record(calcout, "BL:m5:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m5:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m545) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m5:DirectDemand")
{
    field(FLNK, "BL:m5:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m5:DirectCountsCalc")
{
    field(INPA, "BL:m5:DirectDemand")
    field(INPB, "BL:m5:Mres PP")
    field(INPC, "BL:m5:Offset PP")
    field(INPD, "BL:m5:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m5:RawDirectDemand PP")
}

record(ao, "BL:m5:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m5:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,5,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 5")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m5:DirectMotorSeq")
{
    field(LNK1, "BL:m5:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m5:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,5,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m5:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,5,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m5:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,5,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m5:MresSource")
}

record(scalcout, BL:m5:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m5:Mres.INPA CA")
    field(FLNK, "BL:m5:OffsetSource")
}

record(scalcout, "BL:m5:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m5:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m5:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,5,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m5:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m5:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m5:Offset.INPA CA")
}


record(scalcout, BL:m5:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m5:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m5:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,5,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m6, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m6

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M6, edm, motor.edl, motor=BL:m6
# % gui, BRICK1.MOTORS.M6, edmembed, motor-embed-small.edl, motor=BL:m6,filename=motor.edl,box-label=Motor 6

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M6, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m6,DESC=Motor 6, name=BRICK1.MOTORS.M6
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m6,DESC=Motor 6, name=BRICK1.MOTORS.M6
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m6,DESC=Motor 6, name=BRICK1.MOTORS.M6
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M6, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m6

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M6, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M6, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M6, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M6, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M6, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M6, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M6, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M6, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M6, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M6, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M6, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M6, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M6, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M6, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M6, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M6, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M6, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M6, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M6, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M6, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M6, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M6, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M6, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M6, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M6, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M6, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M6, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M6, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M6, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M6, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M6, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M6, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M6, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M6, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M6, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M6, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M6, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M6, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M6, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M6, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M6, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M6, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M6, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M6, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M6, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M6, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M6, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M6, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M6, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M6, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M6, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M6, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M6, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M6, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M6, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M6, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M6, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m6")
{
	field(DESC,"Motor 6")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,6)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m6:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m6:ADDR") {
    field(PINI, "YES")
    field(VAL, "6")
}

# record that holds the PORT
record(stringout, "BL:m6:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m6:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m6:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m6:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m6:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m6:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m6.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m6:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m6:ELOSS
record(ai, "BL:m6:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m6:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m6:CHECK_SYNC") {
  field(INPA, "BL:m6.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m6:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m6:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m6:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m6.RMP CP")
	field(INPB,"BL:m6.REP NPP")
	field(INPC,"BL:m6.MRES NPP")
	field(INPD,"BL:m6.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m6:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m6:FERRORMAX
record(calc, "BL:m6:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m6:FERROR.VAL")
	field(INPB,"BL:m6:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:m6:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m6:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m6:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m6:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m6, BRICK1:M6)
alias(BL:m6:ADDR, BRICK1:M6:ADDR)
alias(BL:m6:PORT, BRICK1:M6:PORT)
alias(BL:m6:SCALE, BRICK1:M6:SCALE)
alias(BL:m6:USER:SDIS, BRICK1M6:USER:SDIS)
alias(BL:m6:SDIS, BRICK1:M6:SDIS)
alias(BL:m6:KILL, BRICK1:M6:KILL)
alias(BL:m6:ELOSS, BRICK1:M6:ELOSS)
alias(BL:m6:ELOSSRC, BRICK1:M6:ELOSSRC)
alias(BL:m6:MR_MOVE_WRITE, BRICK1:M6:MR_MOVE_WRITE)
alias(BL:m6:CHECK_SYNC, BRICK1:M6:CHECK_SYNC)
alias(BL:m6:FERROR, BRICK1:M6:FERROR)
alias(BL:m6:FERRORMAX, BRICK1:M6:FERRORMAX)
alias(BL:m6:FEMAXRESET, BRICK1:M6:FEMAXRESET)
alias(BL:m6:HOMEVIS, BRICK1:M6:HOMEVIS)
alias(BL:m6:HOMEVISSTR, BRICK1:M6:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m6:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m6.MRES CP")
  field(INPB, "BL:m6.DIR CP")
  field(INPC, "BL:m6:SCALE")
  field(OUT, "BL:m6:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m6:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+6`")
  field(FLNK, "BL:m6:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m6:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m6.OFF CP")
  field(OUT, "BL:m6:OFF_SET PP")
}

record(ao, "BL:m6:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+6`")
  field(FLNK, "BL:m6:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m6:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,6)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m6:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,6)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m6:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,6)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m6:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,6)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m6:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,6)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m6:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m6:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m6:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m6:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m6:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m6:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m6:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,6)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m6:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#6P")
  field(DESC, "Motor 6")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m6:HMPOS:CALC") {
  field(INPA, "BL:m6.MRES CP")
  field(INPB, "BL:m6:SCALE")  
  field(INPC, "BL:m6:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m6:HMPOS PP")
}

record(ai, "BL:m6:HMPOS") {
  field(DESC, "Motor 6")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m6:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m6")
  field(OUT, "BL:HM:M6PV PP")
}

record(stringout, "BL:HM:M6PV"){
}

# define a kill record
record(ao, "BL:m6:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,6)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m6:ELOSSVAR") {
  field(CALC, "464+6")
  field(PINI, "YES")
}

record(ai, "BL:m6:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+6`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m6:ELOSSRC") {
  field(OUT, "BL:m6:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m6:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+6`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS6:DESC"){
  field(VAL, "Motor 6")
}

#record(bo, "BL:m6:HOMED") {
#  field(DESC, "Set homed status for axis 6")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m6:HOMEDSET")
#}

#record(calcout, "BL:m6:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m6:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m645) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m6:DirectDemand")
{
    field(FLNK, "BL:m6:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m6:DirectCountsCalc")
{
    field(INPA, "BL:m6:DirectDemand")
    field(INPB, "BL:m6:Mres PP")
    field(INPC, "BL:m6:Offset PP")
    field(INPD, "BL:m6:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m6:RawDirectDemand PP")
}

record(ao, "BL:m6:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m6:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,6,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 6")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m6:DirectMotorSeq")
{
    field(LNK1, "BL:m6:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m6:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m6:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m6:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m6:MresSource")
}

record(scalcout, BL:m6:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m6:Mres.INPA CA")
    field(FLNK, "BL:m6:OffsetSource")
}

record(scalcout, "BL:m6:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m6:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m6:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m6:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m6:Offset.INPA CA")
}


record(scalcout, BL:m6:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m6:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m6:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,6,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M6"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m6:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m6.MRES CP")
  field(INPB, "BL:m6.DIR CP")
  field(INPC, "BL:m6:SCALE")
  field(OUT, "BL:m6:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m6:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+6`")
  field(FLNK, "BL:m6:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m6:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m6.OFF CP")
  field(OUT, "BL:m6:OFF_SET PP")
}

record(ao, "BL:m6:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+6`")
  field(FLNK, "BL:m6:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m6:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,6)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m6:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,6)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m6:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,6)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m6:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,6)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m6:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,6)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m6:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m6:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m6:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m6:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m6:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m6:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m6:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,6)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m6:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#6P")
  field(DESC, "Motor 6")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m6:HMPOS:CALC") {
  field(INPA, "BL:m6.MRES CP")
  field(INPB, "BL:m6:SCALE")  
  field(INPC, "BL:m6:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m6:HMPOS PP")
}

record(ai, "BL:m6:HMPOS") {
  field(DESC, "Motor 6")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m6:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m6")
  field(OUT, "BL:HM:M6PV PP")
}

record(stringout, "BL:HM:M6PV"){
}

# define a kill record
record(ao, "BL:m6:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,6)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m6:ELOSSVAR") {
  field(CALC, "464+6")
  field(PINI, "YES")
}

record(ai, "BL:m6:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+6`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m6:ELOSSRC") {
  field(OUT, "BL:m6:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m6:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+6`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS6:DESC"){
  field(VAL, "Motor 6")
}

#record(bo, "BL:m6:HOMED") {
#  field(DESC, "Set homed status for axis 6")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m6:HOMEDSET")
#}

#record(calcout, "BL:m6:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m6:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m645) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m6:DirectDemand")
{
    field(FLNK, "BL:m6:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m6:DirectCountsCalc")
{
    field(INPA, "BL:m6:DirectDemand")
    field(INPB, "BL:m6:Mres PP")
    field(INPC, "BL:m6:Offset PP")
    field(INPD, "BL:m6:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m6:RawDirectDemand PP")
}

record(ao, "BL:m6:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m6:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,6,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 6")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m6:DirectMotorSeq")
{
    field(LNK1, "BL:m6:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m6:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,6,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m6:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,6,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m6:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,6,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m6:MresSource")
}

record(scalcout, BL:m6:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m6:Mres.INPA CA")
    field(FLNK, "BL:m6:OffsetSource")
}

record(scalcout, "BL:m6:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m6:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m6:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,6,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m6:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m6:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m6:Offset.INPA CA")
}


record(scalcout, BL:m6:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m6:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m6:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,6,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m7, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m7

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M7, edm, motor.edl, motor=BL:m7
# % gui, BRICK1.MOTORS.M7, edmembed, motor-embed-small.edl, motor=BL:m7,filename=motor.edl,box-label=Motor 7

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M7, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m7,DESC=Motor 7, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m7,DESC=Motor 7, name=BRICK1.MOTORS.M7
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m7,DESC=Motor 7, name=BRICK1.MOTORS.M7
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M7, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m7

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M7, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M7, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M7, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M7, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M7, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M7, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M7, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M7, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M7, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M7, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M7, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M7, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M7, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M7, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M7, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M7, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M7, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M7, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M7, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M7, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M7, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M7, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M7, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M7, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M7, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M7, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M7, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M7, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M7, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M7, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M7, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M7, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M7, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M7, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M7, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M7, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M7, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M7, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M7, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M7, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M7, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M7, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M7, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M7, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M7, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M7, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M7, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M7, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M7, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M7, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M7, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M7, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M7, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M7, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M7, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M7, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m7")
{
	field(DESC,"Motor 7")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,7)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m7:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m7:ADDR") {
    field(PINI, "YES")
    field(VAL, "7")
}

# record that holds the PORT
record(stringout, "BL:m7:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m7:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m7:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m7:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m7:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m7:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m7.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m7:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m7:ELOSS
record(ai, "BL:m7:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m7:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m7:CHECK_SYNC") {
  field(INPA, "BL:m7.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m7:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m7:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m7:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m7.RMP CP")
	field(INPB,"BL:m7.REP NPP")
	field(INPC,"BL:m7.MRES NPP")
	field(INPD,"BL:m7.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m7:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m7:FERRORMAX
record(calc, "BL:m7:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m7:FERROR.VAL")
	field(INPB,"BL:m7:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:m7:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m7:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m7:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m7:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m7, BRICK1:M7)
alias(BL:m7:ADDR, BRICK1:M7:ADDR)
alias(BL:m7:PORT, BRICK1:M7:PORT)
alias(BL:m7:SCALE, BRICK1:M7:SCALE)
alias(BL:m7:USER:SDIS, BRICK1M7:USER:SDIS)
alias(BL:m7:SDIS, BRICK1:M7:SDIS)
alias(BL:m7:KILL, BRICK1:M7:KILL)
alias(BL:m7:ELOSS, BRICK1:M7:ELOSS)
alias(BL:m7:ELOSSRC, BRICK1:M7:ELOSSRC)
alias(BL:m7:MR_MOVE_WRITE, BRICK1:M7:MR_MOVE_WRITE)
alias(BL:m7:CHECK_SYNC, BRICK1:M7:CHECK_SYNC)
alias(BL:m7:FERROR, BRICK1:M7:FERROR)
alias(BL:m7:FERRORMAX, BRICK1:M7:FERRORMAX)
alias(BL:m7:FEMAXRESET, BRICK1:M7:FEMAXRESET)
alias(BL:m7:HOMEVIS, BRICK1:M7:HOMEVIS)
alias(BL:m7:HOMEVISSTR, BRICK1:M7:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m7:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m7.MRES CP")
  field(INPB, "BL:m7.DIR CP")
  field(INPC, "BL:m7:SCALE")
  field(OUT, "BL:m7:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m7:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+7`")
  field(FLNK, "BL:m7:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m7:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m7.OFF CP")
  field(OUT, "BL:m7:OFF_SET PP")
}

record(ao, "BL:m7:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+7`")
  field(FLNK, "BL:m7:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m7:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,7)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m7:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,7)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m7:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,7)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m7:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,7)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m7:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,7)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m7:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m7:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m7:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m7:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m7:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m7:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m7:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,7)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m7:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#7P")
  field(DESC, "Motor 7")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m7:HMPOS:CALC") {
  field(INPA, "BL:m7.MRES CP")
  field(INPB, "BL:m7:SCALE")  
  field(INPC, "BL:m7:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m7:HMPOS PP")
}

record(ai, "BL:m7:HMPOS") {
  field(DESC, "Motor 7")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m7:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m7")
  field(OUT, "BL:HM:M7PV PP")
}

record(stringout, "BL:HM:M7PV"){
}

# define a kill record
record(ao, "BL:m7:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,7)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m7:ELOSSVAR") {
  field(CALC, "464+7")
  field(PINI, "YES")
}

record(ai, "BL:m7:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+7`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m7:ELOSSRC") {
  field(OUT, "BL:m7:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m7:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+7`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS7:DESC"){
  field(VAL, "Motor 7")
}

#record(bo, "BL:m7:HOMED") {
#  field(DESC, "Set homed status for axis 7")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m7:HOMEDSET")
#}

#record(calcout, "BL:m7:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m7:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m745) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m7:DirectDemand")
{
    field(FLNK, "BL:m7:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m7:DirectCountsCalc")
{
    field(INPA, "BL:m7:DirectDemand")
    field(INPB, "BL:m7:Mres PP")
    field(INPC, "BL:m7:Offset PP")
    field(INPD, "BL:m7:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m7:RawDirectDemand PP")
}

record(ao, "BL:m7:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m7:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,7,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 7")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m7:DirectMotorSeq")
{
    field(LNK1, "BL:m7:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m7:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m7:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m7:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m7:MresSource")
}

record(scalcout, BL:m7:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m7:Mres.INPA CA")
    field(FLNK, "BL:m7:OffsetSource")
}

record(scalcout, "BL:m7:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m7:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m7:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m7:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m7:Offset.INPA CA")
}


record(scalcout, BL:m7:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m7:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m7:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,7,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M7"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m7:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m7.MRES CP")
  field(INPB, "BL:m7.DIR CP")
  field(INPC, "BL:m7:SCALE")
  field(OUT, "BL:m7:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m7:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+7`")
  field(FLNK, "BL:m7:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m7:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m7.OFF CP")
  field(OUT, "BL:m7:OFF_SET PP")
}

record(ao, "BL:m7:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+7`")
  field(FLNK, "BL:m7:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m7:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,7)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m7:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,7)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m7:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,7)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m7:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,7)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m7:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,7)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m7:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m7:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m7:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m7:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m7:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m7:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m7:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,7)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m7:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#7P")
  field(DESC, "Motor 7")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m7:HMPOS:CALC") {
  field(INPA, "BL:m7.MRES CP")
  field(INPB, "BL:m7:SCALE")  
  field(INPC, "BL:m7:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m7:HMPOS PP")
}

record(ai, "BL:m7:HMPOS") {
  field(DESC, "Motor 7")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m7:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m7")
  field(OUT, "BL:HM:M7PV PP")
}

record(stringout, "BL:HM:M7PV"){
}

# define a kill record
record(ao, "BL:m7:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,7)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m7:ELOSSVAR") {
  field(CALC, "464+7")
  field(PINI, "YES")
}

record(ai, "BL:m7:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+7`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m7:ELOSSRC") {
  field(OUT, "BL:m7:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m7:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+7`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS7:DESC"){
  field(VAL, "Motor 7")
}

#record(bo, "BL:m7:HOMED") {
#  field(DESC, "Set homed status for axis 7")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m7:HOMEDSET")
#}

#record(calcout, "BL:m7:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m7:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m745) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m7:DirectDemand")
{
    field(FLNK, "BL:m7:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m7:DirectCountsCalc")
{
    field(INPA, "BL:m7:DirectDemand")
    field(INPB, "BL:m7:Mres PP")
    field(INPC, "BL:m7:Offset PP")
    field(INPD, "BL:m7:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m7:RawDirectDemand PP")
}

record(ao, "BL:m7:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m7:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,7,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 7")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m7:DirectMotorSeq")
{
    field(LNK1, "BL:m7:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m7:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,7,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m7:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,7,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m7:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,7,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m7:MresSource")
}

record(scalcout, BL:m7:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m7:Mres.INPA CA")
    field(FLNK, "BL:m7:OffsetSource")
}

record(scalcout, "BL:m7:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m7:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m7:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,7,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m7:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m7:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m7:Offset.INPA CA")
}


record(scalcout, BL:m7:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m7:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m7:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,7,4)PMAC_OFFSET")
}# % macro, PMAC, The P prefix for the motor controller (must match P in pmacController.template)

# this template defines a motor with two names:-
# (1) root is BL:m8, the macros fully define the name of the motor
# (2) 'numbered' names of the form BRICK1:Mx where x is the motor number
# names are both assigned to the same PV via aliases in the case basic_asyn_motor
# or simply duplicated for all other included templates, this approach works because
# the PVs all point to the same ASYN parameters and improves maintainability of this
# file

# include motor record from the motor module
#% macro, __doc__, Basic template, including motor record and associated tags
#% macro, P      , Device Prefix
#% macro, M      , Device Suffix
#% macro, PORT   , Asyn port for motor record
#% macro, ADDR   , Address on controller
#% macro, DESC   , Description, displayed on EDM screen
#% macro, MRES   , Motor Step Size (EGU)
#% macro, DTYP   , DTYP of record
#% macro, DIR    , User Direction
#% macro, VBAS   , Base Velocity (EGU/s)
#% macro, VELO   , Velocity (EGU/s)
#% macro, VMAX   , Max Velocity (EGU/s), defaults to VELO
#% macro, ACCL   , Seconds to Velocity
#% macro, BDST   , BL Distance (EGU)
#% macro, BVEL   , BL Velocity (EGU/s)
#% macro, BACC   , BL Seconds to Veloc.
#% macro, PREC   , Display Precision
#% macro, EGU    , Engineering Units
#% macro, DHLM   , Dial High Limit
#% macro, DLLM   , Dial Low Limit
#% macro, HLM    , User High Limit
#% macro, LLM    , User Low Limit
#% macro, HLSV   , HW Lim. Violation Svr
#% macro, INIT   , Startup commands
#% macro, SREV   , Steps per Revolution
#% macro, RRES   , Readback Step Size (EGU)
#% macro, TWV    , Tweak Step Size (EGU)
#% macro, ERES   , Encoder Step Size (EGU)
#% macro, JAR    , Jog Acceleration (EGU/s^2)
#% macro, UEIP   , Use Encoder If Present
#% macro, URIP   , Use RDBL If Present
#% macro, RDBL   , Readback Location, set URIP = 1 if you specify this
#% macro, RLNK   , Readback output link
#% macro, RTRY   , Max retry count
#% macro, DLY    , Readback settle time (s)
#% macro, OFF    , User Offset (EGU)
#% macro, RDBD   , Retry Deadband (EGU)
#% macro, FOFF   , Freeze Offset, 0=variable, 1=frozen
#% macro, ADEL   , Alarm monitor deadband (EGU)
#% macro, NTM    , New Target Monitor, only set to 0 for soft motors
#% macro, FEHIGH , HIGH limit for following error
#% macro, FEHIHI , HIHI limit for following error
#% macro, FEHHSV , HIHI alarm severity for following error
#% macro, FEHSV  , HIGH alarm severity for following error
#% macro, SCALE  , Scale factor, if pmacSetAxisScale is used this should be set
#% macro, HOMEVIS, If 1 then home is visible on the gui
#% macro, HOMEVISSTR, If HOMEVIS=0, then display this text on the gui instead
#% macro, name   , Object name and gui association name
#% macro, alh    , Set this to alh to add the motor to the alarm handler and send emails, 
#                  set to '#' to comment out alh lines
#% macro, gda_name, Name to export this as to GDA
#% macro, gda_desc, Description to export this as to GDA

# AUTOSAVE: level 0 = before record init, level 1 = before AND after record init
#% autosave 0 DVAL OFF
#% autosave 1 DIR DHLM DLLM TWV VBAS VELO ACCL BDST BVEL BACC RDBD EGU RTRY UEIP URIP DLY PREC DISA DISP FOFF OFF FRAC OMSL JVEL JAR ADEL MDEL
#% archiver 0.5 Monitor
#% archiver 0.5 Monitor RBV
#% archiver 10 Monitor OFF
#% archiver 10 Monitor MRES
#% gdatag,template,simpleMotor,,Test
#% gdatag,motor,rw,,RECORD,Motor
#% alh
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m8

# This associates an edm screen with the template
# % gui, BRICK1.MOTORS.M8, edm, motor.edl, motor=BL:m8
# % gui, BRICK1.MOTORS.M8, edmembed, motor-embed-small.edl, motor=BL:m8,filename=motor.edl,box-label=Motor 8

# This associates a BOY screen with the template
# % gui, BRICK1.MOTORS.M8, boydetail, motorApp_opi/motor_detail.opi, P=BL,M=:m8,DESC=Motor 8, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed_box.opi, P=BL,M=:m8,DESC=Motor 8, name=BRICK1.MOTORS.M8
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_embed.opi, P=BL,M=:m8,DESC=Motor 8, name=BRICK1.MOTORS.M8
# FIXME: this should be in pmacUtil or tpmac
# % gui, BRICK1.MOTORS.M8, boyembed, motorApp_opi/motor_homed_embed.opi, P=BL,M=:m8

# This makes the component icon reflect the status and severity
# % gui, BRICK1.MOTORS.M8, status, <pv>.MOVN
# % gui, BRICK1.MOTORS.M8, sevr

# These define what PVs a motor detail screen should contain
# % gui, BRICK1.MOTORS.M8, statusbits, Status,  <pv>.MSTA, Direction Positive, Done, High Limit, Home Limit, Unused, Closed Loop, Following Error, At Home, Encoder Present, Problem, Moving, Gain Support, Comms Error, Low Limit, Homed
# % gui, BRICK1.MOTORS.M8, statusbits, ELoss,  <pv>:ELOSS, Encoder Loss, Amplifier Loss, Sys Fail
# % gui, BRICK1.MOTORS.M8, command, ELoss Clear,  <pv>:ELOSSRC.A
# % gui, BRICK1.MOTORS.M8, statusbits, Limit Violation,  <pv>.LVIO, Lim
# % gui, BRICK1.MOTORS.M8, statusbits, At High Limit,  <pv>.HLS, High
# % gui, BRICK1.MOTORS.M8, statusbits, At Low Limit,  <pv>.LLS, Low
# % gui, BRICK1.MOTORS.M8, demand, User High Limit,  <pv>.HLM
# % gui, BRICK1.MOTORS.M8, demand, User Low Limit,  <pv>.LLM
# % gui, BRICK1.MOTORS.M8, demand, Dial High Limit, <pv>.DHLM
# % gui, BRICK1.MOTORS.M8, demand, Dial Low Limit, <pv>.DLLM

# % gui, BRICK1.MOTORS.M8, demand, Motor demand,  <pv>.VAL
# % gui, BRICK1.MOTORS.M8, readback, Motor readback,  <pv>.RBV
# % gui, BRICK1.MOTORS.M8, command, Stop,  <pv>.STOP
# % gui, BRICK1.MOTORS.M8, command, Home Forward,  <pv>.HOMF
# % gui, BRICK1.MOTORS.M8, command, Home Reverse,  <pv>.HOMR
# % gui, BRICK1.MOTORS.M8, command, Jog Forward, <pv>.JOGF
# % gui, BRICK1.MOTORS.M8, command, Jog Reverse, <pv>.JOGR
# % gui, BRICK1.MOTORS.M8, command, Tweak Forward,  <pv>.TWF
# % gui, BRICK1.MOTORS.M8, command, Tweak Reverse,  <pv>.TWR
# % gui, BRICK1.MOTORS.M8, demand, Tweak Step,  <pv>.TWV
# % gui, BRICK1.MOTORS.M8, command, Kill,  <pv>:KILL.PROC, Kill
# % gui, BRICK1.MOTORS.M8, command, Sync VAL=RBV,  <pv>.SYNC

# % gui, BRICK1.MOTORS.M8, enum, Direction,   <pv>.DIR
# % gui, BRICK1.MOTORS.M8, demand, User Offset,  <pv>.OFF
# % gui, BRICK1.MOTORS.M8, enum, Set/Use,   <pv>.SET
# % gui, BRICK1.MOTORS.M8, enum, Offset,   <pv>.FOFF
# % gui, BRICK1.MOTORS.M8, enum, Use Encoder,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Motor Step Size,  <pv>.MRES
# % gui, BRICK1.MOTORS.M8, readback, Steps per Rev,   <pv>.SREV
# % gui, BRICK1.MOTORS.M8, readback, EGUs per Rev,   <pv>.UREV
# % gui, BRICK1.MOTORS.M8, demand, Encoder Step Size,  <pv>.ERES
# % gui, BRICK1.MOTORS.M8, readback, Readback Step Size,   <pv>.RRES
# % gui, BRICK1.MOTORS.M8, readback, Use Encoder if Present,   <pv>.UEIP

# % gui, BRICK1.MOTORS.M8, demand, Max Velocity,  <pv>.VMAX
# % gui, BRICK1.MOTORS.M8, demand, Base Velocity,   <pv>.VBAS
# % gui, BRICK1.MOTORS.M8, demand, Velocity,  <pv>.VELO
# % gui, BRICK1.MOTORS.M8, demand, Secs to Velocity,  <pv>.ACCL
# % gui, BRICK1.MOTORS.M8, demand, JVEL,   <pv>.JVEL
# % gui, BRICK1.MOTORS.M8, demand, Jog Acceleration,   <pv>.JAR
# % gui, BRICK1.MOTORS.M8, demand, Backlash Distance,   <pv>.BDST
# % gui, BRICK1.MOTORS.M8, demand, Backlash Velocity,   <pv>.BVEL
# % gui, BRICK1.MOTORS.M8, demand, Backlash Secs to Vel,   <pv>.BACC
# % gui, BRICK1.MOTORS.M8, demand, Move Fraction,   <pv>.FRAC
# % gui, BRICK1.MOTORS.M8, demand, Retry Deadband,   <pv>.RDBD
# % gui, BRICK1.MOTORS.M8, demand, Max Retrys,   <pv>.RTRY

# % gui, BRICK1.MOTORS.M8, demand, PREC,   <pv>.PREC
# % gui, BRICK1.MOTORS.M8, demand, EGU,   <pv>.EGU

# % gui, BRICK1.MOTORS.M8, demand, Output Specification,   <pv>.OUT
# % gui, BRICK1.MOTORS.M8, readback, Readback Location,   <pv>.RDBL
# % gui, BRICK1.MOTORS.M8, readback, Desired Output Loc,   <pv>.DOL
# % gui, BRICK1.MOTORS.M8, readback, Output Mode Select,   <pv>.OMSL
# % gui, BRICK1.MOTORS.M8, readback, Readback Out Link,   <pv>.RLNK
# % gui, BRICK1.MOTORS.M8, demand, DMOV Input Link,   <pv>.DINP
# % gui, BRICK1.MOTORS.M8, demand, RMP Input Link,   <pv>.RINP
# % gui, BRICK1.MOTORS.M8, demand, Stop Out Link,   <pv>.STOO


record(motor,"BL:m8")
{
	field(DESC,"Motor 8")
	field(DTYP,"asynMotor")
	field(DIR,"0")
	field(VELO,"100")
	field(VBAS,"0")
	field(ACCL,"0.5")
	field(BDST,"0")
	field(BVEL,"0")
	field(BACC,"")
	field(OUT,"@asyn(Brick,8)")
	field(MRES,"1")
	field(PREC,"3")
	field(EGU,"mm")
	field(DHLM,"0")
	field(DLLM,"0")
	field(HLM,"")
	field(LLM,"")	
	field(HLSV,"MAJOR")
	field(INIT,"")
	field(RTRY,"0")
	field(DLY,"0")	
	field(HVEL,"0")
	field(SREV, "1000")
	field(RRES, "")
	field(TWV, "1")
	field(ERES, "")
	field(JVEL, "100")
	field(JAR, "")
	field(UEIP, "0")
	field(URIP, "0")	
	field(RDBL, "")		
	field(VMAX, "1000")
	field(OFF, "0")
	field(RDBD, "")
	field(FOFF, "0")
	field(ADEL, "0")
	field(NTM, "1")
	field(SDIS, "BL:m8:SDIS.VAL")	
	field(RLNK, "")
}

# record that holds the ADDR
record(ao, "BL:m8:ADDR") {
    field(PINI, "YES")
    field(VAL, "8")
}

# record that holds the PORT
record(stringout, "BL:m8:PORT") {
    field(PINI, "YES")
    field(VAL, "Brick")
}

# record that holds the SCALE
record(ao, "BL:m8:SCALE") {
    field(PINI, "YES")
    field(VAL, "1")
}

# Write a 1 to this record over Channel Access to disable the motor record and prevent CA writes to any field
# including the demand field.
record(ai, "BL:m8:USER:SDIS") {
    field(VAL, "0")
    field(FLNK, "BL:m8:SDIS")
}

# Note: This record forms part of the interface to auto-homing, which uses the "A" field to disable the motor record
# when homing.
# record that will disable and re-enable record if any of its inputs are non-zero
record(calcout, "BL:m8:SDIS") {
  field(DESC, "Disable on non-zero input")
  field(INPL, "BL:m8:USER:SDIS")
  field(CALC, "(A|B|C|D|E|F|G|H|I|J|K|L)>0")
  field(OUT, "BL:m8.DISP PP")
}

# dummy record that looks like a kill command
record(ao, "BL:m8:KILL") {
    field(VAL, "1")
}

# dummy record that looks like eloss status
#% archiver 10 Monitor VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m8:ELOSS
record(ai, "BL:m8:ELOSS") {
    field(PINI, "YES")
    field(HIHI, "1")
    field(HHSV, "MAJOR")    
}

# dummy record that looks like an eloss reset
record(calcout, "BL:m8:ELOSSRC") {
}

# check if SYNC has been pressed
record(calcout, "BL:m8:CHECK_SYNC") {
  field(INPA, "BL:m8.SYNC CP")  
  field(CALC, "A>0")
  field(OOPT, "When Non-zero")
  field(OUT, "BL:m8:MR_MOVE_WRITE.PROC PP")
}

# dummy record that looks like a record to notify a CS about a raw motor move
record(longout, "BL:m8:MR_MOVE_WRITE") {
}

#Record to calculate the following error
#% archiver 1 Monitor
record(calc, "BL:m8:FERROR")
{
	field(DESC,"Following Error")
	field(INPA,"BL:m8.RMP CP")
	field(INPB,"BL:m8.REP NPP")
	field(INPC,"BL:m8.MRES NPP")
	field(INPD,"BL:m8.ERES NPP")
	field(CALC,"ABS((A*C)-(B*D))")
	field(FLNK,"BL:m8:FERRORMAX")
	field(PREC,"3")
	field(EGU, "mm")
}

#Record to store the maximum following error
#% archiver 10 Monitor VAL
#% autosave 1 VAL
#% None $SEVRCOMMAND UP_ANY dls-alh-handler.py BL:m8:FERRORMAX
record(calc, "BL:m8:FERRORMAX")
{
	field(DESC,"Following Error Max")
	field(INPA,"BL:m8:FERROR.VAL")
	field(INPB,"BL:m8:FERRORMAX.VAL")
	field(CALC,"(A>B)?A:B")
	field(HIGH,"0")
	field(HIHI,"0")
	field(HHSV,"NO_ALARM")
	field(HSV, "NO_ALARM")
	field(PREC,"3")
	field(EGU, "mm")
}	

#Record to reset the maximum following error
record(bo, "BL:m8:FEMAXRESET")
{
	field(DESC,"Reset max following error")
	field(DTYP,"Soft Channel")
	field(OUT, "BL:m8:FERRORMAX.VAL")
	field(VAL, "0")
}	


#Record to determin HOME button visibility on the motor.edl screen.
record(bo, "BL:m8:HOMEVIS")
{
	field(DESC,"Home button visibility")
	field(DTYP,"Soft Channel")
	field(VAL, "1")
        field(ZNAM, "Invisible")
	field(ONAM, "Visible")
}	 

#Record to display a message if the HOME buttons are not visible (if HOMEVIS=0).
record(stringout, "BL:m8:HOMEVISSTR")
{
	field(DESC, "Home visibility string")
	field(DTYP,"Soft Channel")
	field(VAL, "Use motor summary screen")
}


# numbered name aliases for all PVs in basic_asyn_motor.template
alias(BL:m8, BRICK1:M8)
alias(BL:m8:ADDR, BRICK1:M8:ADDR)
alias(BL:m8:PORT, BRICK1:M8:PORT)
alias(BL:m8:SCALE, BRICK1:M8:SCALE)
alias(BL:m8:USER:SDIS, BRICK1M8:USER:SDIS)
alias(BL:m8:SDIS, BRICK1:M8:SDIS)
alias(BL:m8:KILL, BRICK1:M8:KILL)
alias(BL:m8:ELOSS, BRICK1:M8:ELOSS)
alias(BL:m8:ELOSSRC, BRICK1:M8:ELOSSRC)
alias(BL:m8:MR_MOVE_WRITE, BRICK1:M8:MR_MOVE_WRITE)
alias(BL:m8:CHECK_SYNC, BRICK1:M8:CHECK_SYNC)
alias(BL:m8:FERROR, BRICK1:M8:FERROR)
alias(BL:m8:FERRORMAX, BRICK1:M8:FERRORMAX)
alias(BL:m8:FEMAXRESET, BRICK1:M8:FEMAXRESET)
alias(BL:m8:HOMEVIS, BRICK1:M8:HOMEVIS)
alias(BL:m8:HOMEVISSTR, BRICK1:M8:HOMEVISSTR)


############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m8:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m8.MRES CP")
  field(INPB, "BL:m8.DIR CP")
  field(INPC, "BL:m8:SCALE")
  field(OUT, "BL:m8:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m8:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+8`")
  field(FLNK, "BL:m8:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m8:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m8.OFF CP")
  field(OUT, "BL:m8:OFF_SET PP")
}

record(ao, "BL:m8:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+8`")
  field(FLNK, "BL:m8:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m8:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,8)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m8:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,8)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m8:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,8)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m8:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,8)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m8:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,8)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m8:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m8:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m8:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m8:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m8:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m8:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m8:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,8)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m8:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#8P")
  field(DESC, "Motor 8")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m8:HMPOS:CALC") {
  field(INPA, "BL:m8.MRES CP")
  field(INPB, "BL:m8:SCALE")  
  field(INPC, "BL:m8:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m8:HMPOS PP")
}

record(ai, "BL:m8:HMPOS") {
  field(DESC, "Motor 8")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m8:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m8")
  field(OUT, "BL:HM:M8PV PP")
}

record(stringout, "BL:HM:M8PV"){
}

# define a kill record
record(ao, "BL:m8:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,8)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m8:ELOSSVAR") {
  field(CALC, "464+8")
  field(PINI, "YES")
}

record(ai, "BL:m8:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+8`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m8:ELOSSRC") {
  field(OUT, "BL:m8:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m8:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+8`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS8:DESC"){
  field(VAL, "Motor 8")
}

#record(bo, "BL:m8:HOMED") {
#  field(DESC, "Set homed status for axis 8")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m8:HOMEDSET")
#}

#record(calcout, "BL:m8:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m8:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m845) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m8:DirectDemand")
{
    field(FLNK, "BL:m8:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m8:DirectCountsCalc")
{
    field(INPA, "BL:m8:DirectDemand")
    field(INPB, "BL:m8:Mres PP")
    field(INPC, "BL:m8:Offset PP")
    field(INPD, "BL:m8:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m8:RawDirectDemand PP")
}

record(ao, "BL:m8:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m8:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,8,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 8")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m8:DirectMotorSeq")
{
    field(LNK1, "BL:m8:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m8:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m8:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m8:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m8:MresSource")
}

record(scalcout, BL:m8:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m8:Mres.INPA CA")
    field(FLNK, "BL:m8:OffsetSource")
}

record(scalcout, "BL:m8:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m8:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m8:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m8:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m8:Offset.INPA CA")
}


record(scalcout, BL:m8:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m8:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m8:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,8,4)PMAC_OFFSET")
}

# add numbered name aliases for above 3 templates
#substitute "P=BRICK1:, M=M8"
############################################################
#
# Template to allow coordinate system kinematics to know
# the resolution of each real motor
#
# Also to allow control of CS mappings of real motors
#
###############################################################


###############################################################
# Mres and Offset
###############################################################

#calc mres to be written
record(calcout, "BL:m8:MRES_CALC") {
  field(CALC, "B?-A*C:A*C")
  field(INPA, "BL:m8.MRES CP")
  field(INPB, "BL:m8.DIR CP")
  field(INPC, "BL:m8:SCALE")
  field(OUT, "BL:m8:MRES_SET PP")
  field(OOPT, "When Non-zero")
}

record(ao, "BL:m8:MRES_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4800+8`")
  field(FLNK, "BL:m8:MR_MOVE_WRITE")
}

#calc offset to be written
record(calcout, "BL:m8:OFF_SET_CALC") {
  field(CALC, "A")
  field(INPA, "BL:m8.OFF CP")
  field(OUT, "BL:m8:OFF_SET PP")
}

record(ao, "BL:m8:OFF_SET") {
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn(Brick,0)PMAC_WD_P`4900+8`")
  field(FLNK, "BL:m8:MR_MOVE_WRITE")
}


###############################################################
# Coordinate System mapping control
###############################################################

# Read back which CS number the axis is in
record(ai, "BL:m8:CsRaw_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn(Brick,8)PMAC_C_AXIS_CS")
    field(PINI, "NO")
    field(SCAN, "I/O Intr")
}

# Set which CS the axis is in via CSController Port Name
record(mbbo, "BL:m8:CsPort") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,8)PMAC_C_GROUP_CS_PORT")
}

record(mbbi, "BL:m8:CsPort_RBV") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,8)PMAC_C_GROUP_CS_PORT_RBV")
  field(SCAN, "I/O Intr")
}

# set the axis' CS assignment (one of A B C U V W X Y Z I)
record(stringout, "BL:m8:CsAxis") {
  field(DTYP, "asynOctetWrite")
  field(OUT, "@asyn(Brick,8)PMAC_C_GROUP_ASSIGN")
}

record(stringin, "BL:m8:CsAxis_RBV") {
  field(DTYP, "asynOctetRead")
  field(INP, "@asyn(Brick,8)PMAC_C_GROUP_ASSIGN_RBV")
  field(SCAN, "I/O Intr")
}# These are the supporting records for doing kill, eloss, and adding autohome 
# support to a motor record

#% macro, SPORT, Asyn port for eloss commands 
# usually PMAC_S<n> for pmacs, the name of the pmacAsynIpPort for bricks
#% macro, HOME, Prefix for autohome instance. Defaults to BL. If unspecified,
# the template contains enough records to keep the motor record happy
#% macro, PMAC, Prefix for pmacStatus instance. Needed to get axis descriptions
# onto pmacStatusAxis screen
#% macro, ALLOW_HOMED_SET, Set to a blank to allow this axis to have its homed
# status manually.  This is set to a comment character by default.

# disable motor when homing
record(calcout, "BL:m8:SDIS") {
#  field(INPA, "BL:HM:HOMING CP")
}

# dummy record in case we aren't homing
record(busy, "BL:HM:HOMING") {
}

# Monitor homing status
record(bi, "BL:m8:HOMING") {
  field(DESC, "Monitor homing status of autohome")
  field(INP, "BL:HM:HOMING CP")
  field(FLNK, "BL:m8:HOMING_CALC")
  field(ZNAM, "Done")
  field(ONAM, "Busy")
}

# report to the driver if this motor is being autohomed
record(calcout, BL:m8:HOMING_CALC)
{
    field(PINI, 1)
    field(INPA, "BL:m8:HOMING")
    field(CALC, "A")
    field(OUT, "BL:m8:HOMING_STATUS PP")
}

# report to the driver if this motor is being autohomed
record(ao, BL:m8:HOMING_STATUS)
{
    field(DESC, "driver update on autohome")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn(Brick,8)HOMING_STATUS")
}


# reports position of motor without offset
record(ai, "BL:m8:HMPOS_RBV") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn(Brick,0)PMAC_VDF_#8P")
  field(DESC, "Motor 8")
  field(SCAN, "I/O Intr")
  field(PINI, "YES")
  field(PREC, "3")
  field(EGU, "mm")
}

record(calcout, "BL:m8:HMPOS:CALC") {
  field(INPA, "BL:m8.MRES CP")
  field(INPB, "BL:m8:SCALE")  
  field(INPC, "BL:m8:HMPOS_RBV CP")  
  field(CALC, "A*B*C")
  field(OUT, "BL:m8:HMPOS PP")
}

record(ai, "BL:m8:HMPOS") {
  field(DESC, "Motor 8")
  field(PREC, "3")
  field(EGU, "mm")
}

# at startup, tell autohome template about this motor
record(stringout, "BL:m8:SETHMPV") {
  field(PINI, "YES")
  field(VAL, "BL:m8")
  field(OUT, "BL:HM:M8PV PP")
}

record(stringout, "BL:HM:M8PV"){
}

# define a kill record
record(ao, "BL:m8:KILL") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,8)PMAC_C_KILL_AXIS")  
  field(VAL, "0")
}

record(calc, "BL:m8:ELOSSVAR") {
  field(CALC, "464+8")
  field(PINI, "YES")
}

record(ai, "BL:m8:ELOSS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn(Brick,0)PMAC_VIS_P`464+8`")  
  field(SCAN, "I/O Intr")  
}

record(calcout, "BL:m8:ELOSSRC") {
  field(OUT, "BL:m8:SEND_ELOSSRC PP") 
  field(DESC, "Write 0 to A to reset Eloss")
  field(CALC, "A")
  field(A, "0")  
}

record(ao, "BL:m8:SEND_ELOSSRC") {
  field(DTYP, "asynInt32")
  field(OUT, "@asyn(Brick,0)PMAC_VIS_P`464+8`")  
}

# Overwrite the description of pmacStatus
record(stringout, "BRICK1:AXIS8:DESC"){
  field(VAL, "Motor 8")
}

#record(bo, "BL:m8:HOMED") {
#  field(DESC, "Set homed status for axis 8")
#  field(ZNAM, "NOT HOMED")
#  field(ONAM, "HOMED")
#  field(FLNK, "BL:m8:HOMEDSET")
#}

#record(calcout, "BL:m8:HOMEDSET") {
#  field(DESC, "Homed status")
#  field(DTYP, "stream")
#  field(CALC, "A")
#  field(INPA, "BL:m8:HOMED")
#  field(OUT, "@pmac.proto setIntVar(m845) BRICK1port")
#}
##############################################################
#
# A record to sit along side each motor record and give direct
# access to the driver without any motor record logic
# may be used with virtual and real motors
#
# This template requires that all real motors mentioned have
# a real underlying motor record (to determine MRES) this is
# not required for virtual motors
#
# This currently only supports demand but could be extended
# to totally replace motor record (perhaps)
#
##############################################################

# % macro, PORT, The asyn port (motor controller or CS controller)
# % macro, ADDR, The asyn address (real or CS axis number)
# % macro, DESC, Description
# % macro, PMAC, PV Prefix for the motor controller
# % macro, P, PV Prefix for direct motors
# % macro, M, Motor PV suffix ('Mx' for real and 'CSx:My' for CS axes)

##############################################################
# Set immediate demand for this motor
##############################################################
#% archiver 0.5 Monitor
record(ao, "BL:m8:DirectDemand")
{
    field(FLNK, "BL:m8:DirectCountsCalc.PROC")
    field(PREC, 4)
}

record(scalcout, "BL:m8:DirectCountsCalc")
{
    field(INPA, "BL:m8:DirectDemand")
    field(INPB, "BL:m8:Mres PP")
    field(INPC, "BL:m8:Offset PP")
    field(INPD, "BL:m8:SCALE")
    field(CALC, "(A-C)/B*D")
    field(OUT, "BL:m8:RawDirectDemand PP")
}

record(ao, "BL:m8:RawDirectDemand")
{
    field(DTYP, "asynFloat64")
    field(FLNK, "BL:m8:DirectMotorSeq")
    field(OUT,  "@asyn(Brick,8,4)MOTOR_MOVE_ABS")
    field(DESC, "Motor 8")
}

# busy record to make ca_put_callback return only once the motor is done moving
record(seq, "BL:m8:DirectMotorSeq")
{
    field(LNK1, "BL:m8:DirectMotorBusy PP")
    field(DO1, "1")
}

record(busy, "BL:m8:DirectMotorBusy")
{
   field(DTYP, "asynInt32")
   field(OUT, "@asyn(Brick,8,4)MOTOR_STATUS_MOVING")
   field(ZNAM, "Idle")
   field(ONAM, "Moving")
   field(PINI, "1")
   field(VAL,  "0")
}


# record that holds the SCALE
# this overrides the definition in basic_asyn_motor.template and connects it to the
# asyn parameter that tracks the scale factor in the driver. This is set by calling
# pmacSetAxisScale (for CS axes this function is exposed to startup via
# pmacSetCoordStepsPerUnit)

record(ao, "BL:m8:SCALE") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn(Brick,8,4)PMAC_MOTOR_SCALE")
}

##############################################################
# Database logic to set the correct ASLO and OFF on
# DirectDemand so that it can be commanded in EGUs
#
# The Mres and Offset are copied into ALSO and OFF from
# the appropriate real motor determined by DirectMotorNumber.
#
# For CS motors DirectMotorNumber is set by the driver when it
# maps a CS motor directly to a real motor.
#
# If as CS motor is not directly mapped then it wants an
# mres of 1 but the scaling means this usually translates
# to 0.0001.
#
# For real motors DirectMotorNumber is always reported as the
# motor's own number
#
# The calculation in MresSource handles linking in the
# correct real_motor mres or the value 1 for kinematic CS axes
#
##############################################################
record(longin, "BL:m8:DirectMotorNumber")
{
    field(PINI, 1)
    field(VAL, 0)
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn(Brick,8,4)PMAC_REAL_MOTOR_NUMBER")
    field(FLNK, "BL:m8:MresSource")
}

record(scalcout, BL:m8:MresSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.MRES CPP',A)):1")
    field(OUT, "BL:m8:Mres.INPA CA")
    field(FLNK, "BL:m8:OffsetSource")
}

record(scalcout, "BL:m8:Mres")
{
    field(INPA, "1") # to be overwritten by MresSource
    field(CALC, "A")
    field(VAL, 1)
    field(PINI, "YES")
    field(OUT,  "BL:m8:MresDrv PP")
    field(PREC, 6)
}

record(ao,"BL:m8:MresDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,8,4)PMAC_MRES")
}

# todo non zero offset in CS kinematic axes no supported
record(scalcout, BL:m8:OffsetSource)
{
    field(DTYP, "Soft Channel")
    field(INPA, "BL:m8:DirectMotorNumber")
    field(CALC, "A?(PRINTF('BRICK1:M%d.OFF CPP',A)):0")
    field(OUT, "BL:m8:Offset.INPA CA")
}


record(scalcout, BL:m8:Offset)
{
    field(INPA, "0") # to be overwritten by OffsetSource
    field(CALC, "A")
    field(PINI, "YES")
    field(OUT,  "BL:m8:OffsetDrv PP")
    field(PREC, 4)
}


record(ao,"BL:m8:OffsetDrv") {
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn(Brick,8,4)PMAC_OFFSET")
}